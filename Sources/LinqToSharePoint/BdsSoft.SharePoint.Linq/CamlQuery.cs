/*
 * LINQ-to-SharePoint
 * http://www.codeplex.com/LINQtoSharePoint
 * 
 * Copyright Bart De Smet (C) 2007
 * info@bartdesmet.net - http://blogs.bartdesmet.net/bart
 * 
 * This project is subject to licensing restrictions. Visit http://www.codeplex.com/LINQtoSharePoint/Project/License.aspx for more information.
 */

/*
 * Version history:
 *
 * 0.2.1 - Introduction of CamlQuery.
 *         Refactoring of PatchPredicate into separate methods.
 *         Patch for negated DateRangesOverlap expressions.
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Xml;
using System.Web.Services.Protocols;
using Microsoft.SharePoint;
using Microsoft.SharePoint.Utilities;

namespace BdsSoft.SharePoint.Linq
{
    /// <summary>
    /// CAML query class, used to represent, parse and execute CAML queries.
    /// </summary>
    internal class CamlQuery
    {
        #region Private members

        /// <summary>
        /// XmlDocument object used to build query fragments; acts a the root for all XML elements used while parsing the query.
        /// </summary>
        internal XmlDocument _doc = new XmlDocument();

        #region Gathered query information

        /// <summary>
        /// Where clause of the query, based on the CAML query format's Where element.
        /// </summary>
        internal XmlElement _where;

        /// <summary>
        /// Ordering clause of the query, based on the CAML query format's OrderBy element.
        /// </summary>
        internal XmlElement _order;

        #region Projection

        /// <summary>
        /// Fields required to perform the projection clause of the query, based on the CAML query format's ViewFields element. Can be empty in case no projection is done and/or all fields are required in the query result.
        /// </summary>
        internal XmlElement _projection;

        /// <summary>
        /// Delegate for the projection logic, generated by compiling the projection's lambda expression (e.g. u => new { u.Name }). Takes an object of the original entity type used in the query (<see cref="_entityType"/>).
        /// </summary>
        private Delegate _project;

        /// <summary>
        /// Set of PropertyInfo objects for all the fields used in the projection portion of the query. Used to build the projection (<see cref="_projection"/>) without duplicates.
        /// </summary>
        private HashSet<PropertyInfo> _projectProps;

        #endregion

        /// <summary>
        /// Optional number of "top" rows to query for, with the semantics of the TOP construct in SQL. Gathered by parsing Take(n) calls.
        /// </summary>
        private int? _top;

        #endregion

        /// <summary>
        /// Entity type of the source list items.
        /// </summary>
        internal Type _entityType;

        /// <summary>
        /// SharePoint data context that will be used to execute the query.
        /// </summary>
        private SharePointDataContext _context;

        private SPList _list;
        private string _wsList;

        #endregion

        internal ParseErrorCollection _errors;

        #region Factory methods

        /// <summary>
        /// Parses a CAML query based on an expression tree.
        /// </summary>
        /// <param name="expression">Expression tree to generate the CAML query object for.</param>
        /// <param name="validate">Used to turn on parse validation.</param>
        /// <returns>CAML query object for the specified expression tree.</returns>
        public static CamlQuery Parse(Expression expression, bool validate)
        {
            //
            // Create a query object and enable validation (optional).
            //
            CamlQuery query = new CamlQuery();
            if (validate)
            {
                query._errors = new ParseErrorCollection();
                query._errors.Expression = expression.ToString();
            }

            //
            // Do the real parsing.
            //
            Parse(query, expression, 0, expression.ToString().Length - 1);

            //
            // Return constructed query object.
            //
            return query;
        }

        /// <summary>
        /// Parses a CAML query based on an expression tree.
        /// </summary>
        /// <param name="query">Query to be completed with parsed information.</param>
        /// <param name="expression">Expression tree to generate the CAML query object for.</param>
        private static void Parse(CamlQuery query, Expression expression, int ppS, int ppE)
        {
            MethodCallExpression mce = expression as MethodCallExpression;
            ConstantExpression ce = expression as ConstantExpression;

            //
            // Method call expression represents a query operator from the System.Linq.Queryable type.
            //
            if (mce != null && mce.Method.DeclaringType == typeof(Queryable))
            {
                //
                // Depth-first parsing of the expression tree.
                //
                Parse(query, mce.Arguments[0], 0, mce.Arguments[0].ToString().Length - 1);

                //
                // Check the extension method called during query creation.
                //
                switch (mce.Method.Name)
                {
                    //
                    // Query expression for filtering.
                    //
                    case "Where":
                        //
                        // Original call = Queryable::Where(source, predicate)
                        //                 where predicate is of type Expression<Func<TSource, bool>>
                        // Parse the query based on the Func<TSource, bool> predicate expression tree.
                        //
                        query.ParsePredicate((LambdaExpression)((UnaryExpression)mce.Arguments[1]).Operand, mce.Arguments[0].ToString().Length + 1, ppE);
                        break;
                    //
                    // Query expression for sorting. Multiple possibilities exist and can act cumulatively.
                    //
                    case "OrderBy":
                    case "OrderByDescending":
                    case "ThenBy":
                    case "ThenByDescending":
                        //
                        // Original call = Queryable::{OrderBy|ThenBy}[Descending](source, keySelector)
                        //                 where keySelector is of type Expression<Func<TSource, TKey>>
                        // Parse the query based on the sort Expression<Func<TSource, TKey>> key selector expression tree; keep track of descending sorts.
                        //
                        query.ParseOrdering((LambdaExpression)((UnaryExpression)mce.Arguments[1]).Operand, mce.Method.Name.EndsWith("Descending", StringComparison.Ordinal), mce.Arguments[0].ToString().Length + 1, ppE);
                        break;
                    //
                    // Query expression for projection.
                    //
                    case "Select":
                        //
                        // Original call = Queryable::Select(source, selector)
                        //                 where selector is of type Expression<Func<TSource, TResult>>
                        // Parse the query based on the Expression<Func<TSource, TResult>> selector.
                        //
                        query.ParseProjection((LambdaExpression)((UnaryExpression)mce.Arguments[1]).Operand, mce.Arguments[0].ToString().Length + 1, ppE);
                        break;
                    //
                    // Query expression for result restriction ("TOP").
                    //
                    case "Take":
                        //
                        // Original call = Queryable::Take(source, count)
                        // Parse the query based on the count value obtained by compilation and dynamic invocation of the count argument to the call.
                        //
                        query.SetResultRestriction((int)Expression.Lambda<Func<int>>(mce.Arguments[1]).Compile().DynamicInvoke());
                        break;
                    //
                    // Currently we don't support additional query operators in LINQ-to-SharePoint.
                    //
                    default:
                        ParseErrors.UnsupportedQueryOperator(query, mce.Method.Name, ppS + mce.Arguments[0].ToString().Length + 1, ppE);
                        return;
                }
            }
            //
            // Constant expression represents the source of the query.
            //
            else if (ce != null)
            {
                Type t = ce.Value.GetType();
                if (t.GetGenericTypeDefinition() == typeof(SharePointList<>))
                {
                    //
                    // Store the entity type.
                    //
                    query._context = (SharePointDataContext)t.GetProperty("Context").GetValue(ce.Value, null);
                    query._entityType = t.GetGenericArguments()[0];
                }
            }
            else
                throw new InvalidOperationException("Unrecognized query statement detected.");
        }

        #endregion

        #region Parsers

        #region Query predicate expression parsing (Where)

        /// <summary>
        /// Parses a query filter expression, resulting in a CAML Where element (<see cref="_where"/>).
        /// </summary>
        /// <param name="predicate">Lambda expression of the query predicate to parse.</param>
        /// <remarks>Only one filter expression can be parsed per query.</remarks>
        private void ParsePredicate(LambdaExpression predicate, int ppS, int ppE)
        {
            //
            // We can support multiple predicates as long no projection operation was carried out.
            //
            if (_projection != null)
                //[PPTODO]
                throw new InvalidOperationException("Can't add another predicate expression to the query.");

            //
            // Calculcate expression body parser positions.
            // E.g. Where(t => ((t.Age >= 24) && t.LastName.StartsWith("Smet")))
            //      ++++++0xxxx                                                -
            // ppS <- ppS + 6(+) + predicate.Parameters[0].Name.Length + 4(x)
            // ppE <- ppE - 1(-)
            //
            ppS += 10 + predicate.Parameters[0].Name.Length;
            ppE -= 1;

            //
            // Parse the predicate recursively, starting without negation (last parameter "positive" set to true).
            //
            PropertyInfo lookup;
            XmlElement pred = ParsePredicate(predicate.Body, predicate.Parameters[0], true, out lookup, ppS, ppE);

            //
            // Predicate can be null because of optimizations.
            //
            if (pred != null)
            {
                //
                // Patches required for lookup fields?
                //
                if (lookup != null)
                    PatchQueryExpressionNode(lookup, ref pred);

                //
                // If this is the first predicate, create a new <Where> element.
                //
                if (_where == null)
                {
                    _where = _doc.CreateElement("Where");
                    _where.AppendChild(pred);
                }
                //
                // Otherwise, add the new predicate to the existing one using an <And> element.
                //
                else
                {
                    XmlElement and = _doc.CreateElement("And");
                    and.AppendChild(pred);
                    and.AppendChild(_where.FirstChild);
                    _where = _doc.CreateElement("Where");
                    _where.AppendChild(and);
                }
            }
        }

        /// <summary>
        /// Parses the given predicate recursively, building up the given query predicate element.
        /// </summary>
        /// <param name="predicate">Predicate expression to be parsed.</param>
        /// <param name="predicateParameter">Parameter of the predicate lambda expression. Used to detect references to the entity type itself.</param>
        /// <param name="isPositive">Indicates whether the predicate should be evaluated as a positive condition or not; serves boolean negation using De Morgan's law.</param>
        /// <param name="lookup">Output parameter for Lookup fields, used to build the query expression for a lookup field.</param>
        /// <returns>Output XML element representing the parsed predicate in CAML syntax.</returns>
        private XmlElement ParsePredicate(Expression predicate, ParameterExpression predicateParameter, bool isPositive, out PropertyInfo lookup, int ppS, int ppE)
        {
            BinaryExpression be;
            UnaryExpression ue;
            MethodCallExpression mce;
            MemberExpression me;
            ConstantExpression ce;

            //
            // By default, no Lookup field will be referenced.
            //
            lookup = null;

            //
            // The given predicate can be a binary expression containing either boolean expressions or conditions that require further parsing.
            //
            if ((be = predicate as BinaryExpression) != null)
            {
                return ParsePredicateBinary(predicate, predicateParameter, isPositive, be, ref lookup, ppS, ppE);
            }
            //
            // A unary expression will occur for boolean negation.
            //
            else if ((ue = predicate as UnaryExpression) != null)
            {
                return ParsePredicateUnary(predicate, predicateParameter, isPositive, ue, ref lookup, ppS, ppE);
            }
            //
            // Converts the unary boolean evaluation like "where u.Member.Value select" or "where u.Age.HasValue select".
            // 
            else if ((me = predicate as MemberExpression) != null)
            {
                return ParsePredicateMember(predicate, predicateParameter, isPositive, me, ref lookup, ppS, ppE);
            }
            //
            // Method calls are supported for a limited set of string operations and for LookupMulti fields.
            //
            else if ((mce = predicate as MethodCallExpression) != null)
            {
                return ParsePredicateMethodCall(predicate, predicateParameter, isPositive, mce, ref lookup, ppS, ppE);
            }
            //
            // Constant values are possible if the user writes clauses like "1 == 1" in the query's where predicate.
            //
            else if ((ce = predicate as ConstantExpression) != null)
            {
                //
                // The value should be boolean-valued.
                //
                if (ce.Value is bool)
                    return GetBooleanPatch((bool)ce.Value);
                else
                    throw new NotSupportedException("Non-boolean constant values are not supported in query predicates.");
            }

            //
            // Fall-through case (shouldn't occur under normal circumstances).
            //
            throw new InvalidOperationException("An unexpected error occurred in the predicate parser.");
        }

        private XmlElement ParsePredicateMember(Expression predicate, ParameterExpression predicateParameter, bool isPositive, MemberExpression me, ref PropertyInfo lookup, int ppS, int ppE)
        {
            //
            // Check for (and trim) Nullable wrapper.
            //
            bool? isNullableHasValue;
            Expression res = CheckForNullableType(me, out isNullableHasValue);

            //
            // Did we find an entity reference?
            //
            if (IsEntityPropertyReference(res))
            {
                MemberExpression mRes = res as MemberExpression;

                //
                // Check for lookup field to propagate lookup query expressions to parent.
                //
                if (mRes.Member.DeclaringType != _entityType)
                {
                    MemberExpression outer = mRes.Expression as MemberExpression;
                    if (!IsEntityPropertyReference(outer))
                        throw new NotSupportedException("Unsupported query expression detected: " + me.ToString() + ".");

                    lookup = (PropertyInfo)outer.Member;
                }

                me = mRes;// (MemberExpression)res;

                XmlElement c;

                //
                // Call to .HasValue? If so, convert to IsNull or IsNotNull.
                //
                if (isNullableHasValue.HasValue && isNullableHasValue.Value)
                    c = _doc.CreateElement(isPositive ? "IsNotNull" : "IsNull");
                //
                // No .HasValue should be either .Value or a non-Nullable boolean. Convert to <Eq> with the member's value.
                //
                else
                {
                    c = _doc.CreateElement("Eq");
                    c.AppendChild(GetValue(isPositive, Helpers.GetFieldAttribute((PropertyInfo)me.Member)));
                }

                //
                // Append field reference.
                //
                c.AppendChild(GetFieldRef((PropertyInfo)me.Member));
                return c;
            }
            else
                throw new NotSupportedException("Unsupported query expression detected: " + me.ToString() + ".");
        }

        private XmlElement ParsePredicateMethodCall(Expression predicate, ParameterExpression predicateParameter, bool isPositive, MethodCallExpression mce, ref PropertyInfo lookup, int ppS, int ppE)
        {
            //
            // Check for CamlElements methods.
            //
            if (mce.Method.DeclaringType == typeof(CamlMethods))
            {
                //
                // DateRangesOverlap support.
                //
                if (mce.Method.Name == "DateRangesOverlap")
                {
                    //
                    // Negation isn't supported.
                    //
                    if (!isPositive)
                        return ParseErrors.CantNegate(this, "DateRangesOverlap", ppS, ppE);

                    //
                    // Get value argument.
                    //
                    Expression valEx = mce.Arguments[0];

                    bool? isNullableHasValue;
                    valEx = CheckForNullableType(valEx, out isNullableHasValue);

                    //
                    // Value argument shouldn't be an entity property reference.
                    //
                    if (IsEntityPropertyReference(valEx))
                        throw new NotSupportedException("A call to DateRangesOverlap should not have an entity property reference as its value argument.");

                    //
                    // Get value element.
                    //
                    XmlElement value = GetDateValue(valEx);

                    //
                    // Field references.
                    //
                    NewArrayExpression fields = mce.Arguments[1] as NewArrayExpression;
                    if (fields == null)
                        throw new InvalidOperationException("An unexpected error occurred in the predicate parser (DateRangesOverlap).");

                    List<XmlElement> fieldRefs = new List<XmlElement>();

                    //
                    // Exception object for unsupported DateRangesOverlap constructs.
                    //
                    Exception drEx = new NotSupportedException("A call to DateRangesOverlap should have entity property references as its fields arguments, all referring to the same entity type.");

                    //
                    // Find all field expressions.
                    //
                    foreach (Expression fieldEx in fields.Expressions)
                    {
                        //
                        // Clean-up the field expression.
                        //
                        Expression fEx = fieldEx;
                        while (fEx.NodeType == ExpressionType.Convert || fEx.NodeType == ExpressionType.ConvertChecked)
                            fEx = ((UnaryExpression)fEx).Operand;

                        fEx = DropToString(fEx);
                        fEx = CheckForNullableType(fEx, out isNullableHasValue);

                        if (!IsEntityPropertyReference(fEx))
                            throw drEx;

                        MemberExpression mex = fEx as MemberExpression;
                        if (mex == null || !(mex.Member is PropertyInfo))
                            throw drEx;

                        //
                        // Lookup properties are supported only if all property references are of the same lookup type.
                        //
                        if (mex.Member.DeclaringType != _entityType)
                        {
                            MemberExpression outer = mex.Expression as MemberExpression;
                            if (!IsEntityPropertyReference(outer))
                                throw drEx;

                            PropertyInfo lookup1 = (PropertyInfo)outer.Member;

                            //
                            // We've already found field references; check that all of these refer to the same entity type.
                            //
                            if (fieldRefs.Count != 0 && (lookup == null || lookup != lookup1))
                                throw drEx;
                            else
                                lookup = lookup1;
                        }

                        //
                        // Add field reference element.
                        //
                        fieldRefs.Add(GetFieldRef((PropertyInfo)mex.Member));
                    }

                    //
                    // Construct and return DateRangesOverlap element.
                    //
                    XmlElement dro = _doc.CreateElement("DateRangesOverlap");
                    dro.AppendChild(value);
                    foreach (XmlElement fieldRef in fieldRefs)
                        dro.AppendChild(fieldRef);
                    return dro;
                }
            }

            //
            // Only method calls on entity type properties are supported.
            //
            Expression ex = DropToString(mce.Object);
            MemberExpression o = ex as MemberExpression;
            if (o == null || !(o.Member is PropertyInfo))
                throw new NotSupportedException("Unsupported query expression detected: " + mce.ToString() + ". Only query expressions applied on entity properties can be translated.");

            //
            // Check for lookup field to propagate lookup query expressions to parent.
            //
            if (o.Member.DeclaringType != _entityType)
            {
                MemberExpression outer = o.Expression as MemberExpression;
                if (!IsEntityPropertyReference(outer))
                    throw new NotSupportedException("Unsupported query expression detected: " + mce.ToString() + ". Only query expressions applied on entity properties can be translated.");

                lookup = (PropertyInfo)outer.Member;
            }

            PropertyInfo property = (PropertyInfo)o.Member;

            //
            // Only string operations "Contains", "StartsWith" and "Equals" are supported in CAML.
            //
            if (mce.Method.DeclaringType == typeof(string))
            {
                //
                // Get the value of the method call argument and ensure it's lambda parameter free.
                //
                Expression arg = mce.Arguments[0];
                EnsureLambdaFree(arg, predicateParameter);

                //
                // Find the value of the method call argument using lamda expression compilation and dynamic invocation.
                //
                object val = Expression.Lambda(arg).Compile().DynamicInvoke();
                string sval = val as string;

                //
                // Build the condition.
                //
                XmlElement cond;
                switch (mce.Method.Name)
                {
                    case "Contains":
                        //
                        // Contains "" is always true.
                        //
                        if (String.IsNullOrEmpty(sval))
                            return null;

                        if (!isPositive)
                            return ParseErrors.CantNegate(this, "Contains", ppS, ppE);
                        cond = _doc.CreateElement("Contains");
                        break;
                    case "StartsWith":
                        //
                        // StartsWith "" is always true.
                        //
                        if (String.IsNullOrEmpty(sval))
                            return null;

                        if (!isPositive)
                            return ParseErrors.CantNegate(this, "BeginsWith", ppS, ppE);
                        cond = _doc.CreateElement("BeginsWith");
                        break;
                    case "Equals":
                        if (val == null)
                        {
                            if (!isPositive)
                                cond = _doc.CreateElement("IsNotNull");
                            else
                                cond = _doc.CreateElement("IsNull");

                            cond.AppendChild(GetFieldRef(property));
                            return cond;
                        }
                        else
                        {
                            if (!isPositive)
                                cond = _doc.CreateElement("Neq");
                            else
                                cond = _doc.CreateElement("Eq");
                        }
                        break;
                    default:
                        throw new NotSupportedException("Unsupported string filtering query expression detected. Only the methods Contains and StartsWith are supported.");
                }
                cond.AppendChild(GetFieldRef(property));

                //
                // Set the value on the condition element.
                //
                if (val != null)
                    cond.AppendChild(GetValue(val, Helpers.GetFieldAttribute(property)));
                else
                    return null;

                return cond;
            }
            //
            // LookupMulti fields support the Contains method call.
            //
            else if (mce.Method.DeclaringType.IsGenericType
                     && mce.Method.DeclaringType.GetGenericTypeDefinition() == typeof(ICollection<>)
                     && mce.Method.Name == "Contains")
            {
                if (!isPositive)
                    return ParseErrors.CantNegate(this, "Contains", ppS, ppE);
                XmlElement cond = _doc.CreateElement("Contains");

                //
                // Get the value of the method call argument and ensure it's lambda parameter free.
                //
                Expression arg = mce.Arguments[0];
                EnsureLambdaFree(arg, predicateParameter);

                //
                // Find the value of the method call argument using lamda expression compilation and dynamic invocation.
                //
                object val = Expression.Lambda(arg).Compile().DynamicInvoke();

                //
                // Contains(null) is considered to be always true.
                //
                if (val == null)
                    return null;

                //
                // Check type of the Contains parameter to match the entity type.
                //
                if (mce.Method.DeclaringType.GetGenericArguments()[0] != val.GetType())
                    throw new NotSupportedException("Contains expressions for LookupMulti fields should match the referenced entity type.");

                //
                // Build condition based on the referenced field and the lookup key field.
                //
                cond.AppendChild(GetFieldRef(property));
                cond.AppendChild(GetValue(val, Helpers.GetFieldAttribute(property)));

                return cond;
            }
            else
                throw new NotSupportedException("Unsupported method call detected in query predicate (" + mce.Method.Name + ").");
        }

        private XmlElement ParsePredicateUnary(Expression predicate, ParameterExpression predicateParameter, bool isPositive, UnaryExpression ue, ref PropertyInfo lookup, int ppS, int ppE)
        {
            //
            // CAML doesn't support boolean negation; therefore, we apply De Morgan's law by inverting the isPositive indicator.
            //
            if (predicate.NodeType == ExpressionType.Not)
            {
                //
                // Calculcate expression body parser positions. Trim Not(.) portion.
                // E.g. Not(t.Age >= 24)
                //      ++++           -
                // ppS <- ppS + 4(+)
                // ppE <- ppE - 1(-
                //
                ppS += 4;
                ppE -= 1;

                PropertyInfo lookup1;
                XmlElement c = ParsePredicate(ue.Operand, predicateParameter, !isPositive, out lookup1, ppS, ppE);

                //
                // Optimized away?
                //
                if (c != null)
                {
                    //
                    // If a Lookup reference was detected, propagate the lookup query expression to the parent.
                    //
                    if (lookup1 != null)
                        lookup = lookup1;
                }

                return c;
            }
            else
                throw new NotSupportedException("Unsupported query expression detected: " + predicate.ToString() + ".");
        }

        private XmlElement ParsePredicateBinary(Expression predicate, ParameterExpression predicateParameter, bool isPositive, BinaryExpression be, ref PropertyInfo lookup, int ppS, int ppE)
        {
            //
            // Calculcate expression body parser positions: trim outer parentheses.
            // E.g. ((t.Age >= 24) && t.LastName.StartsWith("Smet"))
            //      +                                              -
            // ppS <- ppS + 1(+)
            // ppE <- ppE - 1(-)
            //
            ppS += 1;
            ppE -= 1;

            switch (predicate.NodeType)
            {
                //
                // AndAlso boolean expression (&&, AndAlso)
                // And boolean expression     (&,  And)
                // OrElse boolean expression  (||, OrElse)
                // Or boolean expression      (|,  Or)
                //
                case ExpressionType.AndAlso:
                case ExpressionType.And:
                case ExpressionType.OrElse:
                case ExpressionType.Or:
                    {
                        XmlElement c;

                        if (predicate.NodeType == ExpressionType.And || predicate.NodeType == ExpressionType.AndAlso)
                            //
                            // If not evaluated positively, apply De Morgan's law: !(a && b) == !a || !b
                            //
                            c = (isPositive ? _doc.CreateElement("And") : _doc.CreateElement("Or"));
                        else
                            //
                            // If not evaluated positively, apply De Morgan's law: !(a || b) == !a && !b
                            //
                            c = (isPositive ? _doc.CreateElement("Or") : _doc.CreateElement("And")); // De Morgan

                        //
                        // Calculcate expression body parser positions for lhs and rhs.
                        // E.g. (t.Age >= 24) && t.LastName.StartsWith("Smet")
                        //      S           T    D                           E
                        // ppT <- ppS + be.Left.ToString().Length - 1
                        // ppE <- ppE - be.Right.ToString().Length + 1
                        //
                        int ppT = ppS + be.Left.ToString().Length - 1;
                        int ppD = ppE - be.Right.ToString().Length + 1;

                        PropertyInfo lookupLeft, lookupRight;
                        XmlElement left = ParsePredicate(be.Left, predicateParameter, isPositive, out lookupLeft, ppS, ppT);
                        XmlElement right = ParsePredicate(be.Right, predicateParameter, isPositive, out lookupRight, ppD, ppE);

                        //
                        // Optimizations could occur.
                        //
                        if (left != null && right != null)
                        {
                            //
                            // If both lookups are the same (or both null), propagate the lookup query expression to the parent.
                            //
                            if (lookupLeft == lookupRight)
                            {
                                lookup = lookupLeft;
                            }
                            //
                            // If one of the lookups is different, apply a patch and don't propagate the lookup query expression to the parent.
                            //
                            else
                            {
                                lookup = null;

                                if (lookupLeft != null)
                                    PatchQueryExpressionNode(lookupLeft, ref left);
                                if (lookupRight != null)
                                    PatchQueryExpressionNode(lookupRight, ref right);
                            }

                            //
                            // Continue to compose the query expression tree.
                            //
                            c.AppendChild(left);
                            c.AppendChild(right);

                            return c;
                        }
                        //
                        // In case of optimization, cut pruned condition children.
                        //
                        else
                        {
                            //
                            // Only left hand side remains.
                            //
                            if (left != null)
                            {
                                //
                                // If a lookup is found, it can be propagated now because we end up with a single node.
                                //
                                if (lookupLeft != null)
                                {
                                    lookup = lookupLeft;
                                    PatchQueryExpressionNode(lookupLeft, ref left);
                                }

                                return left;
                            }
                            //
                            // Only right hand side remains.
                            //
                            else if (right != null)
                            {
                                //
                                // If a lookup is found, it can be propagated now because we end up with a single node.
                                //
                                if (lookupRight != null)
                                {
                                    lookup = lookupRight;
                                    PatchQueryExpressionNode(lookupRight, ref right);
                                }

                                return right;
                            }
                            //
                            // Both sides of the expression are optimized away.
                            //
                            else
                                return null;
                        }
                    }
                //
                // Remaining binary operations are parsed as conditions. Examples include ==, !=, >, <, >=, <=.
                //
                default:
                    {
                        PropertyInfo lookup1;
                        XmlElement c = GetCondition(be, isPositive, predicateParameter, out lookup1);

                        //
                        // If a Lookup reference was detected, propagate the lookup query expression to the parent.
                        //
                        if (lookup1 != null)
                            lookup = lookup1;

                        return c;
                    }
            }
        }

        /// <summary>
        /// Gets a Boolean patch for use in query predicates. These patches are invalid CAML elements and should be removed by the query parser prior to query execution.
        /// </summary>
        /// <param name="b">Boolean value of the patch.</param>
        /// <returns>Patch representing the specified Boolean value.</returns>
        private XmlElement GetBooleanPatch(bool b)
        {
            XmlElement e = _doc.CreateElement(b ? "TRUE" : "FALSE");
            return e;
        }

        /// <summary>
        /// Patches a query expression node by surrounding it with a Patch element so that it can be replaced with lookup field references upon execution.
        /// </summary>
        /// <param name="lookup">Lookup entity property to make a patch for.</param>
        /// <param name="node">Node of the query expression to be patched.</param>
        private void PatchQueryExpressionNode(PropertyInfo lookup, ref XmlElement node)
        {
            //
            // Make sure the child entity field referenced in the lookup is unique.
            //
            if (_context.EnforceLookupFieldUniqueness)
            {
                FieldAttribute fap = Helpers.GetFieldAttribute(lookup);
                if (fap == null || fap.LookupField == null)
                    throw new InvalidOperationException("An unexpected error has occurred in the query parser (Lookup field patcher).");

                FieldAttribute fac = Helpers.GetFieldAttribute(lookup.PropertyType.GetProperty(fap.LookupField));
                if (fac == null)
                    throw new InvalidOperationException("An unexpected error has occurred in the query parser (Lookup field patcher).");

                if (!fac.PrimaryKey && !fac.IsUnique)
                    throw new NotSupportedException("Lookup field subqueries are only supported for lookup fields that are unique.");
            }

            //
            // Apply the patch.
            //
            XmlElement p = _doc.CreateElement("Patch");
            XmlAttribute a = _doc.CreateAttribute("Field");
            a.Value = lookup.Name;
            p.Attributes.Append(a);
            p.AppendChild(node);
            node = p;
        }

        /// <summary>
        /// Helper method to check whether the given expression is Nullable type wrapper and removes it.
        /// </summary>
        /// <param name="e">Expression to check for Nullable occurrence.</param>
        /// <param name="isHasValue">Output parameter that indicates that the Nullable usage on the given expression was a HasValue member access.</param>
        /// <returns>Nullable-free expression.</returns>
        private static Expression CheckForNullableType(Expression e, out bool? isHasValue)
        {
            MemberExpression me = e as MemberExpression;
            if (me != null && me.Member is PropertyInfo)
            {
                Type t = me.Member.DeclaringType;
                if (t.IsGenericType && t.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    isHasValue = (me.Member.Name == "HasValue");
                    return me.Expression;
                }
            }

            isHasValue = null;
            return e;
        }

        /// <summary>
        /// Detects the use of Microsoft.VisualBasic.CompilerServices.Operators.CompareString and Microsoft.VisualBasic.Strings.StrComp for string equality checks.
        /// </summary>
        /// <param name="condition">Condition to check for CompareString or StrComp presence.</param>
        /// <param name="left">Left operand, will be rewritten by the CompareString or StrComp first parameter if CompareString or StrComp usage was detected.</param>
        /// <param name="right">Right operand, will be rewritten by the CompareString or StrComp second parameter if CompareString or StrComp usage was detected.</param>
        private static void FindVisualBasicCompareStringCondition(BinaryExpression condition, ref Expression left, ref Expression right)
        {
            //
            // Right hand side should be 0 to indicate string equality.
            //
            ConstantExpression ce = condition.Right as ConstantExpression;
            if (ce != null && ce.Value is int && (int)ce.Value == 0)
            {
                //
                // Check for call to static method Microsoft.VisualBasic.CompilerServices.Operators.CompareString or Microsoft.VisualBasic.Strings.StrComp.
                //
                MethodCallExpression mce = condition.Left as MethodCallExpression;
                if (mce != null && mce.Object == null &&
                    (
                         (mce.Method.Name == "CompareString" && mce.Method.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.Operators")
                      || (mce.Method.Name == "StrComp" && mce.Method.DeclaringType.FullName == "Microsoft.VisualBasic.Strings")
                    )
                   )
                {
                    left = mce.Arguments[0];
                    right = mce.Arguments[1];
                }
            }
        }

        /// <summary>
        /// Get the CAML representation for the specified condition.
        /// </summary>
        /// <param name="condition">Condition to translate into CAML.</param>
        /// <param name="isPositive">Indicates whether the condition should be evaluated in a positive context or not; used for inversion of conditions using De Morgan's law.</param>
        /// <param name="predicateParameter">Parameter of the predicate lambda expression. Used to detect references to the entity type itself.</param>
        /// <param name="lookup">Output parameter for Lookup fields, used to build the query expression for a lookup field.</param>
        private XmlElement GetCondition(BinaryExpression condition, bool isPositive, ParameterExpression predicateParameter, out PropertyInfo lookup)
        {
            //
            // Normally, we don't face a lookup field so stick with the default of no lookup.
            //
            lookup = null;

            Expression left = condition.Left;
            Expression right = condition.Right;

            //
            // Detect use of Microsoft.VisualBasic.CompilerServices.Operators.CompareString or Microsoft.VisualBasic.Strings.StrComp.
            //
            FindVisualBasicCompareStringCondition(condition, ref left, ref right);

            //
            // Trim Convert nodes on the both operandi before examining the nodes further on and remove excessive ToString method calls at the end.
            //
            while (left.NodeType == ExpressionType.Convert || left.NodeType == ExpressionType.ConvertChecked)
                left = ((UnaryExpression)left).Operand;
            left = DropToString(left);

            while (right is UnaryExpression && right.NodeType == ExpressionType.Convert || right.NodeType == ExpressionType.ConvertChecked)
                right = ((UnaryExpression)right).Operand;
            right = DropToString(right);

            //
            // Detect and trim Nullable wrappers on both arguments. Keep track of .HasValue calls.
            //
            bool? leftIsNullableHasValue;
            left = CheckForNullableType(left, out leftIsNullableHasValue);
            bool? rightIsNullableHasValue;
            right = CheckForNullableType(right, out rightIsNullableHasValue);

            //
            // If the left operand is a member expression (pointing to an entity property), we'll assume "normal ordering".
            // CAML queries always check the field 'f' against a value 'v' in the order f op v where 'op' is the operator.
            //
            bool correctOrder;
            if (IsEntityPropertyReference(left))
                correctOrder = true;
            else if (IsEntityPropertyReference(right))
                correctOrder = false;
            else
            {
                //
                // Check for references to entity properties. If none are found, the expression can be evaluated right away.
                //
                HashSet<PropertyInfo> eProps = new HashSet<PropertyInfo>();
                FindEntityProperties(condition, predicateParameter, ref eProps);
                if (eProps.Count == 0)
                {
                    object o = Expression.Lambda(condition).Compile().DynamicInvoke();
                    if (o is bool)
                        return GetBooleanPatch((bool)o);
                    else
                        throw new NotSupportedException("Non-boolean constant values are not supported in query predicates.");
                }
                else
                    throw new NotSupportedException("Unsupported query expression detected: " + condition.ToString() + ".");
            }

            //
            // Find the side of the condition that refers to an entity property (lhs).
            //
            MemberExpression lhs = (MemberExpression)(correctOrder ? left : right);
            PropertyInfo entityProperty = (PropertyInfo)lhs.Member;

            //
            // Lookup field reference?
            //
            if (lhs.Member.DeclaringType != _entityType)
            {
                MemberExpression outer = lhs.Expression as MemberExpression;
                if (!IsEntityPropertyReference(outer))
                    throw new NotSupportedException("Unsupported query expression detected: " + condition.ToString() + ".");

                lookup = (PropertyInfo)outer.Member;
            }

            //
            // Ensure that the value side (rhs) of the condition is lambda parameter free.
            //
            Expression rhs = (correctOrder ? right : left);
            EnsureLambdaFree(rhs, predicateParameter);

            //
            // Find DateTime values, possibly special ones including Today and Now.
            //
            XmlElement dateValue = null;
            if (lhs.Type == typeof(DateTime) || lhs.Type == typeof(DateTime?))
                dateValue = GetDateValue(rhs);

            object value = null;
            XmlElement c;

            if (dateValue == null)
            {
                //
                // Get the rhs value by dynamic execution.
                //
                value = Expression.Lambda(rhs).Compile().DynamicInvoke();

                //
                // Any Nullable.HasValue calls detected? Convert to IsNull or IsNotNull elements based on the rhs value, the context positivity and the node type.
                //
                if ((leftIsNullableHasValue.HasValue && leftIsNullableHasValue.Value) || (rightIsNullableHasValue.HasValue && rightIsNullableHasValue.Value))
                {
                    bool isEquality = condition.NodeType == ExpressionType.Equal;
                    bool checkValue = (bool)value;
                    bool isNull = !(checkValue ^ isEquality) ^ isPositive;

                    c = _doc.CreateElement(isNull ? "IsNull" : "IsNotNull");
                    c.AppendChild(GetFieldRef(entityProperty));

                    return c;
                }
            }

            //
            // Variable that holds the CAML equivalent of the condition.
            //
            string camlQueryElement;

            //
            // Check the type of the node for CAML-supported operations.
            //
            switch (condition.NodeType)
            {
                //
                // Equality is commutative, correctOrder doesn't matter.
                //
                case ExpressionType.Equal:
                    camlQueryElement = isPositive ? "Eq" : "Neq";
                    break;
                //
                // Non-equality is commutative, correctOrder doesn't matter.
                //
                case ExpressionType.NotEqual:
                    camlQueryElement = isPositive ? "Neq" : "Eq";
                    break;
                //
                // Less than <=(!correctOrder)=> Greater than
                //
                case ExpressionType.LessThan:
                    if (!correctOrder)
                        //
                        // !(a > b) == a <= b
                        //
                        camlQueryElement = isPositive ? "Gt" : "Leq";
                    else
                        //
                        // !(a < b) == a >= b
                        //
                        camlQueryElement = isPositive ? "Lt" : "Geq";
                    break;
                //
                // Less than or equal <=(!correctOrder)=> Greater than or equal
                //
                case ExpressionType.LessThanOrEqual:
                    if (!correctOrder)
                        //
                        // !(a >= b) == a < b
                        //
                        camlQueryElement = isPositive ? "Geq" : "Lt";
                    else
                        //
                        // !(a <= b) == a > b
                        //
                        camlQueryElement = isPositive ? "Leq" : "Gt";
                    break;
                //
                // Greater than <=(!correctOrder)=> Less than
                //
                case ExpressionType.GreaterThan:
                    if (!correctOrder)
                        //
                        // !(a < b) == a >= b
                        //
                        camlQueryElement = isPositive ? "Lt" : "Geq";
                    else
                        //
                        // !(a > b) == a <= b
                        //
                        camlQueryElement = isPositive ? "Gt" : "Leq";
                    break;
                //
                // Greater than or equal <=(!correctOrder)=> Less than or equal
                //
                case ExpressionType.GreaterThanOrEqual:
                    if (!correctOrder)
                        //
                        // !(a <= b) == a > b
                        //
                        camlQueryElement = isPositive ? "Leq" : "Gt";
                    else
                        //
                        // !(a >= b) == a < b
                        //
                        camlQueryElement = isPositive ? "Geq" : "Lt";
                    break;
                //
                // Currently no support for other binary operations (if any).
                //
                default:
                    throw new NotSupportedException("Unsupported binary operation encountered in query: " + condition + ".");
            }

            //
            // Special treatment for detected date values.
            //
            if (dateValue != null)
            {
                c = _doc.CreateElement(camlQueryElement);
                c.AppendChild(dateValue);
            }
            //
            // If the calculated value is null, we'll use a IsNull or IsNotNull (if isPositive == false) element for the condition in CAML.
            //
            else if (value == null)
            {
                //
                // lhs == null  <=(!isPositive)=>  lhs != null
                //   IsNull                         IsNotNull
                //
                if (condition.NodeType == ExpressionType.Equal)
                    c = _doc.CreateElement(isPositive ? "IsNull" : "IsNotNull");
                //
                // lhs != null  <=(!isPositive)=>  lhs == null
                //  IsNotNull                        IsNull
                //
                else if (condition.NodeType == ExpressionType.NotEqual)
                    c = _doc.CreateElement(isPositive ? "IsNotNull" : "IsNull");
                else
                    throw new InvalidOperationException("Null value encountered in query condition. Only equality and non-equality null checks can be translated.");
            }
            //
            // Type-specific processing required in translating the query to CAML.
            //
            else
            {
                Type enumCheck = entityProperty.PropertyType;
                if (enumCheck.IsGenericType && enumCheck.GetGenericTypeDefinition() == typeof(Nullable<>))
                    enumCheck = Nullable.GetUnderlyingType(enumCheck);

                //
                // Enums represent Choice or MultiChoice fields.
                //
                if (enumCheck != null && enumCheck.IsSubclassOf(typeof(Enum))) //FIX v0.1.2
                {
                    //
                    // Enums might be compiled to numeric values; reconstruct the enum back if needed.
                    //
                    if (!(value is Enum) && value is uint) // TODO: require uint base type for enums (spec)
                        value = Enum.ToObject(enumCheck, (uint)value);

                    //
                    // Check whether the type of the value has been marked as [Flags].
                    //
                    FlagsAttribute[] fa = (FlagsAttribute[])value.GetType().GetCustomAttributes(typeof(FlagsAttribute), false);

                    //
                    // Choice type case.
                    //
                    if (fa == null || fa.Length == 0)
                    {
                        c = _doc.CreateElement(camlQueryElement);
                        c.AppendChild(GetValue(value, Helpers.GetFieldAttribute(entityProperty)));
                    }
                    //
                    // MultiChoice type case.
                    //
                    else
                    {
                        //
                        // Check for each value of the MultiChoice enum definition whether or not it is set for the given value.
                        //
                        Queue<XmlElement> values = new Queue<XmlElement>();
                        uint enumValue = (uint)value;
                        Type enumType = value.GetType();
                        FieldAttribute f = Helpers.GetFieldAttribute(entityProperty);

                        foreach (uint o in Enum.GetValues(enumType))
                            if ((enumValue & o) == o)
                                values.Enqueue(GetValue(Enum.ToObject(enumType, o), f));

                        //
                        // If no flags values have been set, we're faced with an invalid value.
                        //
                        if (values.Count == 0)
                            throw new InvalidOperationException("Unrecognized enumeration flags value: " + value + ".");
                        else
                        {
                            //
                            // For MultiChoice field queries we need to construct a CAML condition tree consisting of conjunctions.
                            //
                            // E.g. translation of e.X == MC.A | MC.B | MC.C (pseudo-CAML):
                            //    <And>
                            //       <Eq><FieldRef Name="X" /><Value>A</Value></Eq>
                            //       <And>
                            //          <Eq><FieldRef Name="X" /><Value>B</Value></Eq>
                            //          <Eq><FieldRef Name="X" /><Value>C</Value></Eq>
                            //       </And>
                            //    </And>
                            //
                            // NOTE: This translation causes a semantic mismatch between SharePoint and C#. A condition like "e.X == MC.A | MC.B | MC.C"
                            //       has an absolute equality characteristic in C# while CAML has a more relaxed evaluation where e.X == MC.A means that
                            //       option A should be set on field X, while it doesn't say anything about possible other values being present.
                            //       In LINQ-to-SharePoint, e.X == MC.A | MC.B | MC.C means that choices A, B and C should be set, but not necessarily
                            //       exclusively; that is, other choices may be set and the MC.A | MC.B | MC.C represents a subset of the actual value.
                            //
                            c = null;
                            while (values.Count > 0)
                                c = AppendMultiChoiceCondition(camlQueryElement, entityProperty, values.Dequeue(), c);
                        }

                        return c;
                    }
                }
                //
                // Other fields can be processed in a generic fashion.
                //
                else
                {
                    c = _doc.CreateElement(camlQueryElement);
                    c.AppendChild(GetValue(value, Helpers.GetFieldAttribute(entityProperty)));
                }
            }

            //
            // Append the FieldRef element to the condition element and return the condition.
            //
            c.AppendChild(GetFieldRef(entityProperty));
            return c;
        }

        /// <summary>
        /// Retrieves the XM -representation for the DateTime value represented in the specified expression.
        /// </summary>
        /// <param name="dateValue">Expression containing a DateTime value to be converted to XML.</param>
        /// <returns>XML representation for the specified DateTime value expression.</returns>
        private XmlElement GetDateValue(Expression dateValue)
        {
            /*
             * KNOWN ISSUES: see work item 2032
             */

            bool isNow = false;
            bool isToday = false;

            MemberExpression me = dateValue as MemberExpression;
            if (me != null && me.Type == typeof(DateTime))
            {
                Type dt = me.Member.DeclaringType;
                if (dt == typeof(DateTime) || dt == typeof(CamlMethods))
                {
                    isNow = me.Member.Name == "Now";
                    isToday = me.Member.Name == "Today";
                }
            }

            //
            // Value element.
            //
            XmlElement valueElement = _doc.CreateElement("Value");
            XmlAttribute type = _doc.CreateAttribute("Type");
            type.Value = "DateTime";
            valueElement.Attributes.Append(type);

            //
            // [DateTime|CamlElements].Now and [DateTime|CamlElements].Today calls require special treatment.
            //
            if (isNow || isToday)
                valueElement.AppendChild(_doc.CreateElement(isNow ? "Now" : "Today"));
            else
            {
                object value = Expression.Lambda(dateValue).Compile().DynamicInvoke();
                valueElement.InnerText = SPUtility.CreateISO8601DateTimeFromSystemDateTime((DateTime)value);
            }

            return valueElement;
        }

        /// <summary>
        /// Helper method to support MultiChoice field conditions by building a tree of And CAML elements.
        /// </summary>
        /// <param name="condition">Condition node textual representation, e.g. Eq.</param>
        /// <param name="field">Entity property to construct the MultiChoice condition node for.</param>
        /// <param name="value">Value for the MultiChoice condition.</param>
        /// <param name="parent">Current tree of MultiChoice conditions to add the new condition node to. Should be null to start creating a condition tree.</param>
        /// <returns></returns>
        /// <example>
        /// If parent == null:
        /// <![CDATA[
        /// <condition>
        ///    value
        ///    <FieldRef Name="field" />
        /// </condition>
        /// ]]>
        /// 
        /// If parent != null:
        /// <![CDATA[
        /// <And>
        ///    <condition>
        ///       value
        ///       <FieldRef Name="field" />
        ///    </condition>
        ///    parent
        /// </And>
        /// ]]>
        /// </example>
        private XmlElement AppendMultiChoiceCondition(string condition, PropertyInfo field, XmlElement value, XmlElement parent)
        {
            //
            // Create condition element with the child tree and the FieldRef element.
            //
            XmlElement cond = _doc.CreateElement(condition);
            cond.AppendChild(value);
            cond.AppendChild(GetFieldRef(field));

            //
            // If no parent is present yet, we'll just return the condition element.
            //
            if (parent == null)
                return cond;
            //
            // If we're deeper in the tree, we'll take the current parent and lift it to a new And element together with the newly created condition.
            //
            else
            {
                XmlElement c = _doc.CreateElement("And");
                c.AppendChild(cond);
                c.AppendChild(parent);
                return c;
            }
        }

        /// <summary>
        /// Get a CAML Value element that represents the given value for the given field.
        /// </summary>
        /// <param name="value">Field value to get a Value element for.</param>
        /// <param name="field">Field to get a Value element for.</param>
        /// <returns>CAML Value element representing the given value for the given field.</returns>
        private XmlElement GetValue(object value, FieldAttribute field)
        {
            //
            // Create Value element and set the Type attribute.
            //
            XmlElement valueElement = _doc.CreateElement("Value");
            XmlAttribute type = _doc.CreateAttribute("Type");
            type.Value = field.FieldType.ToString();
            valueElement.Attributes.Append(type);

            //
            // Null-check
            //
            if (value == null)
                return valueElement;

            //
            // DateTime fields should be converted to ISO 8601 date/time representation in SharePoint.
            //
            if (value is DateTime)
                valueElement.InnerText = SPUtility.CreateISO8601DateTimeFromSystemDateTime((DateTime)value);
            //
            // Boolean fields in SharePoint are represented as 1 or 0.
            //
            else if (value is bool)
                valueElement.InnerText = ((bool)value ? "1" : "0");
            //
            // For enums, we should get the name of the field value which can be mapped using a ChoiceAttribute.
            // Only single-valued enum objects should occur here (i.e. no flag combinations).
            //
            else if (value is Enum)
            {
                string choice = Enum.GetName(value.GetType(), value);
                valueElement.InnerText = GetChoiceName(value.GetType(), choice);
            }
            //
            // Support for lookup fields (v0.2.0.0).
            //
            else if (value is SharePointListEntity)
            {
                if (field.LookupField == null)
                    throw new InvalidOperationException("The Lookup field " + field.Field + " doesn't have an associated LookupField attribute property set.");

                //
                // Find the property used in the Lookup display.
                //
                PropertyInfo lookupField = value.GetType().GetProperty(field.LookupField);
                if (lookupField == null)
                    throw new InvalidOperationException("The Lookup field " + field.Field + " links to a non-existing LookupField " + field.LookupField + ".");

                //
                // Get value of the Lookup field property.
                //
                object o = lookupField.GetValue(value, null);
                if (o == null)
                    throw new InvalidOperationException("The Lookup field " + field.Field + " has a null-valued LookupField " + field.LookupField + ". Did you mean a null-check on the Lookup field instead?");

                valueElement.InnerText = o.ToString();
            }
            //
            // Other types will be converted to a string.
            // TODO: I18n issues might occur for numeric values; this should be checked.
            //
            else
                valueElement.InnerText = value.ToString();

            return valueElement;
        }

        /// <summary>
        /// Gets the SharePoint CHOICE value for a given enum field.
        /// </summary>
        /// <param name="enumType">Enum type to map the specified field for.</param>
        /// <param name="field">Enum field name to map to a SharePoint CHOICE value.</param>
        /// <returns>SharePoint CHOICE value corresponding with the given enum field.</returns>
        private static string GetChoiceName(Type enumType, string field)
        {
            FieldInfo fi = enumType.GetField(field);

            //
            // Check whether a ChoiceAttribute is applied on the field of the enum. If so, return the mapped name, otherwise take the field name itself.
            //
            ChoiceAttribute[] ca = fi.GetCustomAttributes(typeof(ChoiceAttribute), false) as ChoiceAttribute[];
            if (ca != null && ca.Length != 0 && ca[0] != null)
                return ca[0].Choice;
            else
                return field;
        }

        #endregion

        #region Query ordering expression parsing (OrderBy*, ThenBy*)

        /// <summary>
        /// Parses a query ordering expression, resulting in a CAML OrderBy element (<see crf="_order"/>).
        /// </summary>
        /// <param name="ordering">Lambda expression of the query ordering key selector to parse.</param>
        /// <param name="descending">Indicates whether or not the ordering should be descending.</param>
        /// <remarks>Multiple ordering expressions per query are supported.</remarks>
        private void ParseOrdering(LambdaExpression ordering, bool descending, int ppS, int ppE)
        {
            //
            // If no ordering epxression has been encountered before, construct the OrderBy CAML element.
            //
            if (_order == null)
                _order = _doc.CreateElement("OrderBy");

            //
            // Trim ToString() calls for ordering expressions on textual fields. Allows more flexibility.
            //
            Expression orderExpression = DropToString(ordering.Body);

            //
            // Convert the ordering expression as a MemberExpression.
            //
            MemberExpression me = orderExpression as MemberExpression;

            bool? isHasValue;
            me = (MemberExpression)CheckForNullableType(me, out isHasValue);

            //
            // Make sure the expression is a MemberExpression and points to a property on the entity type.
            //
            if (me != null && me.Member.DeclaringType == _entityType && me.Member is PropertyInfo
                //
                // If nullable, it shouldn't be a call to HasValue.
                //
                && (!isHasValue.HasValue || (isHasValue.HasValue && !isHasValue.Value))
                )
            {
                //
                // Obtain a FieldRef element for the property on the entity type being referred to.
                //
                XmlElement fieldRef = GetFieldRef((PropertyInfo)me.Member);

                //
                // For descending orderings, an Ascending="FALSE" attribute should be added to the FieldRef elements.
                //
                if (descending)
                {
                    XmlAttribute ascending = _doc.CreateAttribute("Ascending");
                    ascending.Value = "FALSE";
                    fieldRef.Attributes.Append(ascending);
                }

                //
                // Append the FieldRef element to the OrderBy ordering clause.
                //
                _order.AppendChild(fieldRef);
            }
            else
                //[PPTODO]
                throw new NotSupportedException("Unsupported ordering expression detected: " + ordering.Body + ". Ordering expressions should only contain individual entity property expressions.");
        }

        #endregion

        #region Query projection expression parsing (Select)

        /// <summary>
        /// Parses a query projection expression, resulting in a CAML ViewFields element (<see crf="_projection"/>).
        /// </summary>
        /// <param name="projection">Lambda expression of the query projection to parse.</param>
        /// <remarks>Only one projection expression can be parsed per query.</remarks>
        private void ParseProjection(LambdaExpression projection, int ppS, int ppE)
        {
            //
            // Equiprojections (u => u) can be ignored.
            //
            if (projection.Parameters[0] == projection.Body)
                return;

            //
            // If no projection has been encountered before, construct the ViewFields CAML element.
            // There should only be one projection per query.
            //
            if (_projection == null)
                _projection = _doc.CreateElement("ViewFields");
            else
                //[PPTODO]
                throw new InvalidOperationException("Second projection expression encountered during parsing. Only one projection expression can be translated for each query. Did you use LINQ query syntax?");

            //
            // Compile the projection for execution during query result fetching.
            //
            _project = projection.Compile();

            //
            // Create the set with entity properties used in projection and populate it.
            //
            _projectProps = new HashSet<PropertyInfo>();
            FindEntityProperties(projection.Body, projection.Parameters[0], ref _projectProps);

            //
            // Populate the ViewFields element with FieldRef elements pointing to the properties used in the projection.
            //
            HashSet<string> fields = new HashSet<string>();
            foreach (PropertyInfo property in _projectProps)
            {
                //
                // Get the field and field name corresponding to the current entity property.
                //
                XmlElement field = GetFieldRef(property);
                string fieldName = field.Attributes["Name"].Value;

                //
                // Filter for duplicates that can occur because of multi-choice values with fill-in choices.
                //
                if (field != null && !fields.Contains(fieldName))
                {
                    fields.Add(fieldName);
                    _projection.AppendChild(field);
                }
            }
        }

        #endregion

        #region Query result restriction (Take)

        /// <summary>
        /// Sets the restriction on the number of results returned by the query, with semantics like "TOP" in SQL.
        /// </summary>
        /// <param name="limit">Restriction on the number of results returned by the query.</param>
        /// <remarks>Multiple restrictions per query are supported and will result in the mimimum of all restrictions to be effective.</remarks>
        private void SetResultRestriction(int limit)
        {
            //
            // If no top value has been set yet, take the specified value; otherwise, take the minimum of the current value and the specified value.
            //
            _top = (_top == null ? limit : Math.Min(_top.Value, limit));
        }

        #endregion

        #endregion

        #region Helper methods to work with conditions and entity property expressions.

        /// <summary>
        /// Checks whether an expression is a reference to an entity property or not.
        /// </summary>
        /// <param name="e">Expression to be checked.</param>
        /// <returns>True if the expression refers to an entity property; otherwise false.</returns>
        private static bool IsEntityPropertyReference(Expression e)
        {
            MemberExpression me = e as MemberExpression;

            if (me != null && me.Member is PropertyInfo)
            {
                FieldAttribute field = Helpers.GetFieldAttribute((PropertyInfo)me.Member);
                if (field != null)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Helper method to drop excessive tail ToString calls on string instances for a given expression.
        /// </summary>
        /// <param name="e">Expression to drop excessive tail ToString calls for.</param>
        /// <returns>Expression without tail ToString calls on string instances.</returns>
        private static Expression DropToString(Expression e)
        {
            while (true)
            {
                //
                // Only look for ToString calls on the root level, as MethodCallExpression objects.
                //
                MethodCallExpression mc = e as MethodCallExpression;

                //
                // Only parameterless ToString() calls on strings should be trimmed off.
                //
                if (mc != null && mc.Object != null && mc.Object.Type == typeof(string) && mc.Method.Name == "ToString" && mc.Method.GetParameters().Length == 0)
                    e = mc.Object;
                else
                    break;
            }
            return e;
        }

        /// <summary>
        /// Recursive method to ensure that a given expression doesn't contain a dependency on a given lambda parameter.
        /// </summary>
        /// <param name="e">Expression to validate.</param>
        /// <param name="parameter">Forbidden lambda parameter to look for.</param>
        /// <exception cref="NotSupportedException">Occurs when the specified lambda parameter is found in the expression.</exception>
        private void EnsureLambdaFree(Expression e, ParameterExpression parameter)
        {
            #region Local variables

            //
            // These variables are kept to avoid needless casting which would occur in constructs like this:
            //   if (e is Abc)
            //   {
            //      Abc abc = (Abc)e;
            //      ...
            //   }
            //

            MemberExpression me;
            ParameterExpression pe;
            BinaryExpression be;
            UnaryExpression ue;
            ConditionalExpression ce;
            InvocationExpression ie;
            LambdaExpression le;
            ListInitExpression lie;
            MemberInitExpression mie;
            MethodCallExpression mce;
            NewExpression ne;
            NewArrayExpression nae;
            TypeBinaryExpression tbe;

            #endregion

            //
            // Base case - member expression is candidate for entity property reference.
            //
            if ((me = e as MemberExpression) != null)
            {
                EnsureLambdaFree(me.Expression, parameter);
            }
            //
            // Base case - reference to lambda expression parameter is candidate for a reference to the whole entity type.
            //
            else if ((pe = e as ParameterExpression) != null)
            {
                //
                // Check that the parameter matches the projection lambda expression's parameter.
                //
                if (pe == parameter)
                    throw new NotSupportedException("Invalid query condition detected. Make sure references to entity type properties only occur on one side of a condition.");
            }
            //
            // b.Method(b.Left, b.Right)
            //
            else if ((be = e as BinaryExpression) != null)
            {
                EnsureLambdaFree(be.Left, parameter);
                EnsureLambdaFree(be.Right, parameter);
            }
            //
            // u.Method(u.Operand)
            //
            else if ((ue = e as UnaryExpression) != null)
            {
                EnsureLambdaFree(ue.Operand, parameter);
            }
            //
            // (c.Test ? c.IfTrue : c.IfFalse)
            //
            else if ((ce = e as ConditionalExpression) != null)
            {
                EnsureLambdaFree(ce.IfFalse, parameter);
                EnsureLambdaFree(ce.IfTrue, parameter);
                EnsureLambdaFree(ce.Test, parameter);
            }
            //
            // i.Expression(i.Arguments[0], ..., i.Arguments[i.Argument.Count - 1])
            //
            else if ((ie = e as InvocationExpression) != null)
            {
                EnsureLambdaFree(ie.Expression, parameter);
                foreach (Expression ex in ie.Arguments)
                    EnsureLambdaFree(ex, parameter);
            }
            //
            // (l.Parameters[0], ..., l.Parameters[l.Parameters.Count - 1]) => l.Body
            //
            else if ((le = e as LambdaExpression) != null)
            {
                EnsureLambdaFree(le.Body, parameter);
                foreach (Expression ex in le.Parameters)
                    EnsureLambdaFree(ex, parameter);
            }
            //
            // li.NewExpression { li.Expressions[0], ..., li.Expressions[li.Expressions.Count - 1] }
            //
            else if ((lie = e as ListInitExpression) != null)
            {
                EnsureLambdaFree(lie.NewExpression, parameter);
                foreach (Expression ex in lie.Expressions)
                    EnsureLambdaFree(ex, parameter);
            }
            //
            // Member initialization expression requires recursive processing of MemberBinding objects.
            //
            else if ((mie = e as MemberInitExpression) != null)
            {
                EnsureLambdaFree(mie.NewExpression, parameter);

                //
                // Maintain a queue to mimick recursion on MemberBinding objects. Enqueue the original bindings.
                //
                Queue<MemberBinding> memberBindings = new Queue<MemberBinding>();
                foreach (MemberBinding b in mie.Bindings)
                    memberBindings.Enqueue(b);

                //
                // Process all bindings.
                //
                while (memberBindings.Count > 0)
                {
                    MemberBinding b = memberBindings.Dequeue();

                    MemberAssignment ma = (MemberAssignment)b;
                    MemberListBinding mlb = (MemberListBinding)b;
                    MemberMemberBinding mmb = (MemberMemberBinding)b;

                    if (ma != null)
                        EnsureLambdaFree(ma.Expression, parameter);
                    else if (mlb != null)
                        foreach (Expression ex in mlb.Expressions)
                            EnsureLambdaFree(ex, parameter);
                    //
                    // Recursion if a MemberBinding contains other bindings.
                    //
                    else if (mmb != null)
                        foreach (MemberBinding mb in mmb.Bindings)
                            memberBindings.Enqueue(mb);
                }
            }
            //
            // mc.Object->mc.Method(mc.Arguments[0], ..., mc.Arguments[mc.Arguments.Count - 1])
            //
            else if ((mce = e as MethodCallExpression) != null)
            {
                if (mce.Object != null)
                    EnsureLambdaFree(mce.Object, parameter);
                foreach (Expression ex in mce.Arguments)
                    EnsureLambdaFree(ex, parameter);
            }
            //
            // new n.Constructor(n.Arguments[0], ..., n.Arguments[n.Arguments.Count - 1])
            //
            else if ((ne = e as NewExpression) != null)
            {
                foreach (Expression ex in ne.Arguments)
                    EnsureLambdaFree(ex, parameter);
            }
            //
            // { na.Expressions[0], ..., na.Expressions[n.Expressions.Count - 1] }
            //
            else if ((nae = e as NewArrayExpression) != null)
            {
                foreach (Expression ex in nae.Expressions)
                    EnsureLambdaFree(ex, parameter);
            }
            else if ((tbe = e as TypeBinaryExpression) != null)
            {
                EnsureLambdaFree(tbe.Expression, parameter);
            }
        }

        #endregion

        #region Helper methods for FieldRef element creation

        /// <summary>
        /// Gets a CAML FieldRef element for the specified entity property.
        /// </summary>
        /// <param name="property">Entity property to get the FieldRef element for.</param>
        /// <returns>FieldRef element for the specified entity property.</returns>
        private XmlElement GetFieldRef(PropertyInfo property)
        {
            //
            // Get mapping attribute and make sure it has been set.
            //
            FieldAttribute fld = Helpers.GetFieldAttribute(property);
            if (fld == null)
                throw new InvalidOperationException("Missing field mapping attribute for entity property " + property.Name + ".");

            XmlElement fieldRef = _doc.CreateElement("FieldRef");
            XmlAttribute fieldName = _doc.CreateAttribute("Name");
            fieldName.Value = XmlConvert.EncodeName(fld.Field);
            fieldRef.Attributes.Append(fieldName);
            return fieldRef;
        }

        #endregion

        #region Helpers methods to work with entity properties

        /// <summary>
        /// Recursive method to find all references to entity properties in a projection expression.
        /// </summary>
        /// <param name="e">Expression to search for references to entity properties.</param>
        /// <param name="parameter">Lambda parameter used by the expression. Used to detect references to the entity type itself.</param>
        /// <param name="result">HashSet to store results in. Marked explicitly as a ref parameter to indicate its output characteristic.</param>
        private void FindEntityProperties(Expression e, ParameterExpression parameter, ref HashSet<PropertyInfo> result)
        {
            #region Local variables

            //
            // These variables are kept to avoid needless casting which would occur in constructs like this:
            //   if (e is Abc)
            //   {
            //      Abc abc = (Abc)e;
            //      ...
            //   }
            //

            MemberExpression me;
            ParameterExpression pe;
            BinaryExpression be;
            UnaryExpression ue;
            ConditionalExpression ce;
            InvocationExpression ie;
            LambdaExpression le;
            ListInitExpression lie;
            MemberInitExpression mie;
            MethodCallExpression mce;
            NewExpression ne;
            NewArrayExpression nae;
            TypeBinaryExpression tbe;

            #endregion

            //
            // Base case - member expression is candidate for entity property reference.
            //
            if ((me = e as MemberExpression) != null)
            {
                bool? isHasValue;
                me = (MemberExpression)CheckForNullableType(me, out isHasValue);

                //
                // Check that the member expression refers to a property on the entity type of the original query.
                //
                PropertyInfo prop = me.Member as PropertyInfo;
                if (prop != null && me.Member.DeclaringType == _entityType && Helpers.GetFieldAttribute(prop) != null)
                    result.Add(prop);
            }
            //
            // Base case - reference to lambda expression parameter is candidate for a reference to the whole entity type.
            //
            else if ((pe = e as ParameterExpression) != null)
            {
                //
                // Check that the parameter matches the projection lambda expression's parameter.
                //
                if (pe == parameter)
                    foreach (PropertyInfo prop in _entityType.GetProperties())
                        if (Helpers.GetFieldAttribute(prop) != null)
                            result.Add(prop);
            }
            //
            // b.Method(b.Left, b.Right)
            //
            else if ((be = e as BinaryExpression) != null)
            {
                FindEntityProperties(be.Left, parameter, ref result);
                FindEntityProperties(be.Right, parameter, ref result);
            }
            //
            // u.Method(u.Operand)
            //
            else if ((ue = e as UnaryExpression) != null)
            {
                FindEntityProperties(ue.Operand, parameter, ref result);
            }
            //
            // (c.Test ? c.IfTrue : c.IfFalse)
            //
            else if ((ce = e as ConditionalExpression) != null)
            {
                FindEntityProperties(ce.IfFalse, parameter, ref result);
                FindEntityProperties(ce.IfTrue, parameter, ref result);
                FindEntityProperties(ce.Test, parameter, ref result);
            }
            //
            // i.Expression(i.Arguments[0], ..., i.Arguments[i.Argument.Count - 1])
            //
            else if ((ie = e as InvocationExpression) != null)
            {
                FindEntityProperties(ie.Expression, parameter, ref result);
                foreach (Expression ex in ie.Arguments)
                    FindEntityProperties(ex, parameter, ref result);
            }
            //
            // (l.Parameters[0], ..., l.Parameters[l.Parameters.Count - 1]) => l.Body
            //
            else if ((le = e as LambdaExpression) != null)
            {
                FindEntityProperties(le.Body, parameter, ref result);
                foreach (Expression ex in le.Parameters)
                    FindEntityProperties(ex, parameter, ref result);
            }
            //
            // li.NewExpression { li.Expressions[0], ..., li.Expressions[li.Expressions.Count - 1] }
            //
            else if ((lie = e as ListInitExpression) != null)
            {
                FindEntityProperties(lie.NewExpression, parameter, ref result);
                foreach (Expression ex in lie.Expressions)
                    FindEntityProperties(ex, parameter, ref result);
            }
            //
            // Member initialization expression requires recursive processing of MemberBinding objects.
            //
            else if ((mie = e as MemberInitExpression) != null)
            {
                FindEntityProperties(mie.NewExpression, parameter, ref result);

                //
                // Maintain a queue to mimick recursion on MemberBinding objects. Enqueue the original bindings.
                //
                Queue<MemberBinding> memberBindings = new Queue<MemberBinding>();
                foreach (MemberBinding b in mie.Bindings)
                    memberBindings.Enqueue(b);

                MemberAssignment ma;
                MemberListBinding mlb;
                MemberMemberBinding mmb;

                //
                // Process all bindings.
                //
                while (memberBindings.Count > 0)
                {
                    MemberBinding b = memberBindings.Dequeue();

                    if ((ma = b as MemberAssignment) != null)
                        FindEntityProperties(ma.Expression, parameter, ref result);
                    else if ((mlb = b as MemberListBinding) != null)
                        foreach (Expression ex in mlb.Expressions)
                            FindEntityProperties(ex, parameter, ref result);
                    //
                    // Recursion if a MemberBinding contains other bindings.
                    //
                    else if ((mmb = b as MemberMemberBinding) != null)
                        foreach (MemberBinding mb in mmb.Bindings)
                            memberBindings.Enqueue(mb);
                }
            }
            //
            // mc.Object->mc.Method(mc.Arguments[0], ..., mc.Arguments[mc.Arguments.Count - 1])
            //
            else if ((mce = e as MethodCallExpression) != null)
            {
                if (mce.Object != null)
                    FindEntityProperties(mce.Object, parameter, ref result);
                foreach (Expression ex in mce.Arguments)
                    FindEntityProperties(ex, parameter, ref result);
            }
            //
            // new n.Constructor(n.Arguments[0], ..., n.Arguments[n.Arguments.Count - 1])
            //
            else if ((ne = e as NewExpression) != null)
            {
                foreach (Expression ex in ne.Arguments)
                    FindEntityProperties(ex, parameter, ref result);
            }
            //
            // { na.Expressions[0], ..., na.Expressions[n.Expressions.Count - 1] }
            //
            else if ((nae = e as NewArrayExpression) != null)
            {
                foreach (Expression ex in nae.Expressions)
                    FindEntityProperties(ex, parameter, ref result);
            }
            else if ((tbe = e as TypeBinaryExpression) != null)
            {
                FindEntityProperties(tbe.Expression, parameter, ref result);
            }
        }

        #endregion

        #region Query execution and enumeration

        /// <summary>
        /// Triggers the query and fetches results.
        /// </summary>
        /// <returns>Query results.</returns>
        public IEnumerator<T> Execute<T>()
        {
            //
            // Version check required for the list?
            //
            if (_context.CheckListVersion)
                _CheckVersion();

            //
            // We don't want the default view, so we'll make an exhaustive list of all the properties to retrieve.
            //
            if (_projection == null)
            {
                _projection = _doc.CreateElement("ViewFields");

                HashSet<string> fields = new HashSet<string>();
                foreach (PropertyInfo property in _entityType.GetProperties())
                {
                    if (Helpers.GetFieldAttribute(property) != null)
                    {
                        //
                        // Get the field and field name corresponding to the current entity property.
                        //
                        XmlElement field = GetFieldRef(property);
                        string fieldName = field.Attributes["Name"].Value;

                        //
                        // Filter for duplicates that can occur because of multi-choice values with fill-in choices.
                        //
                        if (field != null && !fields.Contains(fieldName))
                        {
                            fields.Add(fieldName);
                            _projection.AppendChild(field);
                        }
                    }
                }
            }

            //
            // Patch the query for possible Lookup field references.
            //
            bool? optimized = PatchQueryPredicate();
            if (optimized != null)
            {
                //
                // Predicate evaluates to true. Remove the query predicate.
                //
                if (optimized.Value)
                    _where = null;
                //
                // Predicate evaluates to false. No results will be fetched.
                //
                else
                    return VoidResult<T>();
            }

            //
            // Perform query via the SharePoint Object Model or via SharePoint web services.
            //
            ListAttribute la = Helpers.GetListAttribute(_entityType);
            if (_context._site != null)
            {
                _list = _context._site.RootWeb.GetList(la.Path);
                return GetEnumeratorSp<T>();
            }
            else
            {
                _wsList = la.List;
                return GetEnumeratorWs<T>();
            }
        }

        /// <summary>
        /// Helper method to return a void result if the query predicate evaluates to a constant false value.
        /// </summary>
        /// <returns>Empty sequence.</returns>
        private IEnumerator<T> VoidResult<T>()
        {
            yield break;
        }

        #region Enumeration helpers

        /// <summary>
        /// Performs a list version check to make sure that the exported list definition matches the online list version.
        /// </summary>
        private void _CheckVersion()
        {
            int version;

            //
            // Check version via the SharePoint Object Model or via SharePoint web services.
            //
            if (_context._site != null)
                version = _list.Version;
            else
            {
                XmlNode lst = _context._wsProxy.GetList(_wsList);
                version = int.Parse(lst.Attributes["Version"].Value, CultureInfo.InvariantCulture.NumberFormat);
            }

            //
            // Find the list attribute, which is required to perform a list version match check.
            //
            if (GetListAttribute().Version != version)
                throw new InvalidOperationException("List version mismatch between entity type and list definition on the server.");
        }

        /// <summary>
        /// Helper method to get the ListAttribute applied on the entity object. An InvalidOperationException will be thrown if no ListAttribute is found.
        /// </summary>
        /// <returns>ListAttribute applied on the entity object.</returns>
        private ListAttribute GetListAttribute()
        {
            return Helpers.GetListAttribute(_entityType);
        }

        /// <summary>
        /// Patches the query predicate to eliminate Lookup field references by subqueries.
        /// </summary>
        /// <returns>Null if the query predicate wasn't optimized away; a Boolean value with the constant query predicate value if the whole query was optimized to one single constant.</returns>
        private bool? PatchQueryPredicate()
        {
            //
            // Patch Lookup field references.
            //
            Patch(_where);

            //
            // Eliminate Boolean patches by tree pruning.
            //
            return Prune(_where);
        }

        /// <summary>
        /// Patches the query predicate represented by the given node to eliminate Lookup field references by subqueries.
        /// </summary>
        /// <param name="node">Query predicate node to be patched.</param>
        private void Patch(XmlNode node)
        {
            //
            // Any work to do?
            //
            if (node == null)
                return;

            foreach (XmlNode child in node.ChildNodes)
            {
                XmlElement e = child as XmlElement;
                if (e != null)
                {
                    //
                    // Find <Patch> tags.
                    //
                    if (e.Name == "Patch")
                    {
                        //
                        // Get information about the Lookup field.
                        //
                        string field = e.Attributes["Field"].Value;
                        PropertyInfo lookupField = _entityType.GetProperty(field);
                        FieldAttribute lookup = Helpers.GetFieldAttribute(lookupField);
                        if (lookup.FieldType != FieldType.Lookup)
                            throw new InvalidOperationException("An unexpected error has occurred in the query parser (Lookup field patcher).");

                        //
                        // Get information about the Lookup list.
                        //
                        ListAttribute innerListAttribute = Helpers.GetListAttribute(lookupField.PropertyType);
                        string innerList = innerListAttribute.List;

                        //
                        // Get the CAML from the patch.
                        //
                        string caml = e.InnerXml;

                        //
                        // Only retrieve the lookup column value (display column).
                        //
                        XmlElement viewFields = _doc.CreateElement("ViewFields");

                        XmlElement viewLookupField = _doc.CreateElement("FieldRef");
                        XmlAttribute lookupFieldName = _doc.CreateAttribute("Name");
                        lookupFieldName.Value = XmlConvert.EncodeName(lookup.LookupField);
                        viewLookupField.Attributes.Append(lookupFieldName);
                        viewFields.AppendChild(viewLookupField);

                        //
                        // Prepare list of subquery results.
                        //
                        ArrayList fks = new ArrayList();

                        //
                        // Use SharePoint object model.
                        //
                        if (_context._site != null)
                        {
                            //
                            // Build the query.
                            //
                            SPQuery query = new SPQuery();
                            XmlElement q = _doc.CreateElement("Where");
                            q.InnerXml = caml;
                            query.Query = q.OuterXml;
                            query.ViewFields = viewFields.InnerXml;
                            query.IncludeMandatoryColumns = false;
                            query.IncludePermissions = false;
                            query.IncludeAttachmentVersion = false;
                            query.IncludeAttachmentUrls = false;
                            query.IncludeAllUserPermissions = false;

                            //
                            // Log it.
                            //
                            DoLogging(innerList, q, null, viewFields);

                            //
                            // Get subquery results.
                            //
                            foreach (SPListItem item in _context._site.RootWeb.Lists[innerList].GetItems(query))
                            {
                                fks.Add(item[lookup.LookupField]);
                            }
                        }
                        //
                        // Use SharePoint web services.
                        //
                        else
                        {
                            //
                            // Build the query.
                            //
                            XmlElement query = _doc.CreateElement("Query");
                            XmlElement where = _doc.CreateElement("Where");
                            where.InnerXml = caml;
                            query.AppendChild(where);

                            XmlNode queryOptions = _doc.CreateElement("QueryOptions");

                            XmlNode includeMandatoryColumns = _doc.CreateElement("IncludeMandatoryColumns");
                            includeMandatoryColumns.InnerText = "FALSE";
                            queryOptions.AppendChild(includeMandatoryColumns);

                            //
                            // Log it.
                            //
                            DoLogging(innerList, where, null, viewFields);

                            //
                            // Get results.
                            //
                            XmlNode res = _context._wsProxy.GetListItems(innerList, null, query, viewFields, null, queryOptions, null);
                            DataSet ds = new DataSet();
                            ds.Locale = CultureInfo.InvariantCulture;
                            ds.ReadXml(new StringReader(res.OuterXml));
                            DataTable tbl = ds.Tables["row"];

                            //
                            // Get subquery results.
                            //
                            foreach (DataRow row in tbl.Rows)
                            {
                                fks.Add(row["ows_" + lookup.LookupField]);
                            }
                        }

                        //
                        // Create patch.
                        //
                        XmlElement patch = null;
                        foreach (object o in fks)
                        {
                            XmlElement val = GetValue(o, lookup);
                            patch = CreatePatch("Eq", lookupField, val, patch);
                        }

                        //
                        // Apply patch. If no Lookup field reference patch is found, a Boolean false-valued patch will be inserted to allow for subsequent pruning.
                        //
                        if (patch != null) //FIX
                            e.ParentNode.ReplaceChild(patch, e);
                        else
                            e.ParentNode.ReplaceChild(GetBooleanPatch(false), e);
                    }
                    else
                        Patch(e);
                }
            }
        }

        /// <summary>
        /// Prunes Boolean patches from the predicate tree.
        /// </summary>
        /// <param name="node">Predicate tree to be pruned.</param>
        /// <returns></returns>
        private bool? Prune(XmlNode node)
        {
            //
            // Any work to do?
            //
            if (node == null)
                return null;

            XmlElement e = node as XmlElement;
            if (e != null)
            {
                bool? b1, b2;

                //
                // Find binary nodes and Boolean patch tags.
                //
                switch (e.Name)
                {
                    case "Where":
                        if (e.ChildNodes.Count == 1)
                        {
                            b1 = Prune(e.ChildNodes[0]);
                            if (b1 == null)
                                return null;
                            else
                                return b1.Value;
                        }
                        else
                            return true;
                    case "And":
                        b1 = Prune(e.ChildNodes[0]);
                        b2 = Prune(e.ChildNodes[1]);

                        if (b1 != null && b2 != null)
                            return b1.Value && b2.Value;
                        else if (b1 != null)
                        {
                            //
                            // (false && x) == false
                            //
                            if (!b1.Value)
                                return false;
                            //
                            // (true && x) == x
                            //
                            else
                                e.ParentNode.ReplaceChild(e.ChildNodes[1], e);
                        }
                        else if (b2 != null)
                        {
                            //
                            // (x && false) == false
                            //
                            if (!b2.Value)
                                return false;
                            //
                            // (x && true) == x
                            //
                            else
                                e.ParentNode.ReplaceChild(e.ChildNodes[0], e);
                        }
                        break;
                    case "Or":
                        b1 = Prune(e.ChildNodes[0]);
                        b2 = Prune(e.ChildNodes[1]);

                        if (b1 != null && b2 != null)
                            return b1.Value || b2.Value;
                        else if (b1 != null)
                        {
                            //
                            // (true || x) == true
                            //
                            if (b1.Value)
                                return true;
                            //
                            // (false || x) == x
                            //
                            else
                                e.ParentNode.ReplaceChild(e.ChildNodes[1], e);
                        }
                        else if (b2 != null)
                        {
                            //
                            // (x || true) == true
                            //
                            if (b2.Value)
                                return true;
                            //
                            // (x || false) == x
                            //
                            else
                                e.ParentNode.ReplaceChild(e.ChildNodes[0], e);
                        }
                        break;
                    case "TRUE":
                        return true;
                    case "FALSE":
                        return false;
                }
            }

            return null;
        }

        /// <summary>
        /// Helper method to create a Lookup field patch by building a tree of Or CAML elements.
        /// </summary>
        /// <param name="condition">Condition node textual representation, e.g. Eq.</param>
        /// <param name="field">Entity property to construct the Lookup patch for.</param>
        /// <param name="value">Value for the Lookup condition.</param>
        /// <param name="parent">Current tree of the Lookup patch to add the new condition node to. Should be null to start creating a condition tree.</param>
        /// <returns></returns>
        /// <example>
        /// If parent == null:
        /// <![CDATA[
        /// <condition>
        ///    value
        ///    <FieldRef Name="field" />
        /// </condition>
        /// ]]>
        /// 
        /// If parent != null:
        /// <![CDATA[
        /// <Or>
        ///    <condition>
        ///       value
        ///       <FieldRef Name="field" />
        ///    </condition>
        ///    parent
        /// </Or>
        /// ]]>
        /// </example>
        private XmlElement CreatePatch(string condition, PropertyInfo field, XmlElement value, XmlElement parent)
        {
            //
            // Create condition element with the child tree and the FieldRef element.
            //
            XmlElement cond = _doc.CreateElement(condition);
            cond.AppendChild(value);
            cond.AppendChild(GetFieldRef(field));

            //
            // If no parent is present yet, we'll just return the condition element.
            //
            if (parent == null)
                return cond;
            //
            // If we're deeper in the tree, we'll take the current parent and lift it to a new Or element together with the newly created condition.
            //
            else
            {
                XmlElement c = _doc.CreateElement("Or");
                c.AppendChild(cond);
                c.AppendChild(parent);
                return c;
            }
        }

        /// <summary>
        /// Helper method to execute a query and fetch results using the SharePoint Object Model.
        /// </summary>
        /// <returns>Query results.</returns>
        private IEnumerator<T> GetEnumeratorSp<T>()
        {
            //
            // Construct the query ready for consumption by the SharePoint Object Model, without <Query> root element.
            //
            StringBuilder queryBuilder = new StringBuilder();
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.OmitXmlDeclaration = true;
            settings.ConformanceLevel = ConformanceLevel.Auto;
            using (XmlWriter xw = XmlWriter.Create(queryBuilder, settings))
            {
                if (this._where != null && this._where.ChildNodes.Count != 0)
                    this._where.WriteTo(xw);
                if (this._order != null)
                    this._order.WriteTo(xw);
                xw.Flush();
            }

            //
            // Make the SharePoint SPQuery object.
            //
            SPQuery query = new SPQuery();
            query.Query = queryBuilder.ToString();
            query.IncludeMandatoryColumns = false;

            //
            // Include projection fields if a projection clause has been parsed.
            //
            if (_projection != null)
            {
                query.ViewFields = _projection.InnerXml;
            }

            //
            // In case a row limit (Take) was found, set the limit on the query.
            //
            if (_top != null)
            {
                uint top = (uint)_top.Value;
                if (top == 0) //FIX: query.RowLimit = 0 seems to be ineffective.
                    yield break;
                else
                    query.RowLimit = top;
            }

            //
            // Perform logging of the gathered information.
            //
            DoLogging(_list.Title, _where, _order, _projection);

            //
            // Execute the query via the SPList object.
            //
            SPListItemCollection items;
            try
            {
                items = _list.GetItems(query);
            }
            catch (Exception ex)
            {
                throw new SharePointConnectionException("Error occurred when connecting to the SharePoint site at " + _context._site.Url + ".", ex);
            }

            //
            // Fetch results using an iterator.
            //
            foreach (SPListItem item in items)
            {
                yield return GetItem<T>(item, null);
            }
        }

        /// <summary>
        /// Helper method to execute a query and fetch results using SharePoint web services.
        /// </summary>
        /// <returns>Query results.</returns>
        private IEnumerator<T> GetEnumeratorWs<T>()
        {
            //
            // Construct the query ready for consumption by the SharePoint web services, including a <Query> root element.
            //
            XmlNode query = _doc.CreateElement("Query");
            if (this._where != null && this._where.ChildNodes.Count != 0)
                query.AppendChild(this._where);
            if (this._order != null)
                query.AppendChild(this._order);

            //
            // Set query options.
            //
            XmlNode queryOptions = _doc.CreateElement("QueryOptions");

            //
            // Perform logging of the gathered information.
            //
            DoLogging(_wsList, _where, _order, _projection);

            //
            // Retrieve the results of the query via a web service call, using the projection and a row limit (if set).
            //
            uint top = 0;
            if (_top != null)
            {
                top = (uint)_top.Value;
                if (top == 0) //FIX: don't roundtrip to server if no results are requested.
                    yield break;
            }

            XmlNode res;
            try
            {
                res = _context._wsProxy.GetListItems(_wsList, null, query, _projection, _top == null ? null : top.ToString(), queryOptions, null);
            }
            catch (SoapException ex)
            {
                throw new SharePointConnectionException("Error occurred when connecting to the SharePoint web service at " + _context._wsProxy.Url + ".", ex);
            }

            //
            // Store results in a DataSet for easy iteration.
            // TODO: the DataSet approach could be replaced by raw XML parsing.
            //
            DataSet ds = new DataSet();
            ds.ReadXml(new StringReader(res.OuterXml));
            DataTable tbl = ds.Tables["row"];

            //
            // Make sure results are available. If not, return nothing.
            //
            if (tbl == null)
                yield break;

            //
            // Fetch results using an iterator.
            //
            foreach (DataRow row in tbl.Rows)
            {
                yield return GetItem<T>(null, row);
            }
        }

        /// <summary>
        /// Helper method to log query information before fetching results.
        /// </summary>
        /// <param name="list">List that's being queried.</param>
        /// <param name="where">Query predicate.</param>
        /// <param name="order">Ordering clause.</param>
        /// <param name="projection">Projection clause.</param>
        private void DoLogging(string list, XmlElement where, XmlElement order, XmlElement projection)
        {
            //
            // Check whether logging is enabled or not.
            //
            if (_context.Log != null)
            {
                //
                // List general info.
                //
                if (_context._site != null)
                    _context.Log.WriteLine("Query for " + list + " over object model...");
                else
                    _context.Log.WriteLine("Query for " + list + " over web services...");

                //
                // Do the remainder of the logging (CAML).
                //
                Helpers.LogTo(_context.Log, where, order, projection);

                //
                // Spacing to distinguish between subsequent queries.
                //
                _context.Log.WriteLine();
                _context.Log.Flush();
            }
        }

        /// <summary>
        /// Constructs a query result object based on the given item that was retrieved either via the SharePoint object model or via the SharePoint list web service.
        /// </summary>
        /// <param name="item">Item retrieved via the SharePoint object model.</param>
        /// <param name="row">Item retrieved via the SharePoint list web service.</param>
        /// <!--<param name="validItem">Indicates whether or not the retrieved item should be returned in the result set.</param>-->
        /// <returns>Query result object for the query, reflecting the final result (possibly after projection).</returns>
        /// <remarks>Either item or row should be null.</remarks>
        private T GetItem<T>(SPListItem item, DataRow row)//, out bool validItem)
        {
            //validItem = true;

            //
            // Create an instance of the entity type. This instance will be used to perform the projection operation on (if any).
            //
            object result = Activator.CreateInstance(_entityType);

            //
            // Get the collection of properties that have to be set on the entity. If a projection isn't present, all properties will be set; otherwise, only the required properties will be set.
            //
            IEnumerable<PropertyInfo> props = (_project != null ? (IEnumerable<PropertyInfo>)_projectProps : typeof(T).GetProperties());

            //
            // Data comes from the SharePoint Object Model.
            //
            if (item != null)
            {
                foreach (PropertyInfo p in props)
                {
                    AssignResultProperty<T>(item, null, p, result);//, out validItem);
                    //if (!validItem)
                    //    return default(T);
                }
            }
            //
            // Data comes from the SharePoint list web service.
            //
            else
            {
                foreach (PropertyInfo p in props)
                {
                    AssignResultProperty<T>(null, row, p, result);//, out validItem);
                    //if (!validItem)
                    //    return default(T);
                }
            }

            //
            // Perform projection if required.
            //
            if (_project == null)
                return (T)result;
            else
                return (T)_project.DynamicInvoke(result);
        }

        /// <summary>
        /// Assigns a value from the query result to a given property of the entity object.
        /// </summary>
        /// <param name="item">Query result item retrieved using the SharePoint object model.</param>
        /// <param name="row">Query result item retrieved using the SharePoint lists web service.</param>
        /// <param name="property">Property to set on the entity object.</param>
        /// <param name="target">Entity object to set the property for.</param>
        private void AssignResultProperty<T>(SPListItem item, DataRow row, PropertyInfo property, object target)//, out bool validItem)
        {
            //
            // Convert to entity to set property values via SetValue method if an entity type is used.
            //
            SharePointListEntity entity = target as SharePointListEntity;

            //
            // Get the field mapping attribute for the given property.
            //
            FieldAttribute field = Helpers.GetFieldAttribute(property);
            if (field == null)
                throw new InvalidOperationException("Missing field mapping attribute for entity property " + property.Name + ".");

            //
            // Get the value of the property either using the SharePoint list object or using the current DataRow.
            //
            object val;
            string valueAsString;
            if (item != null)
                //
                // Results have a field name which is XML encoded.
                //
                val = item[XmlConvert.EncodeName(field.Field)];
            else
            {
                //
                // Results from the web service have columns prefixed by ows_.
                //
                string col = "ows_" + field.Field;

                //
                // If no results were found with a specific column, it won't be present in the DataRow. We can ignore this property then.
                //
                if (!row.Table.Columns.Contains(col))
                    return;
                val = row[col];
            }

            //
            // If no value has been set, ignore this property.
            //
            if (val == null || val is DBNull)
                return;

            //
            // Get the property type in order to do subsequent value parsing. If the type is Nullable<X>, return typeof(X).
            //
            Type propertyType = property.PropertyType;
            if (propertyType.IsGenericType && propertyType.GetGenericTypeDefinition() == typeof(Nullable<>))
                propertyType = Nullable.GetUnderlyingType(propertyType);

            //
            // Enums require special treatment in order to set flags and/or fill-in choices.
            //
            if (propertyType.IsSubclassOf(typeof(Enum)))
            {
                val = AssignResultPropertyAsEnum(property, target, field, val, propertyType);
            }
            //
            // If the value is of type string, we'll do additional parsing to assign the value to the property.
            //
            else if ((valueAsString = val as string) != null)
            {
                //
                // Calculated fields are prefixed by a type indicator, followed by a ;# separator. We'll trim this off and keep the remainder which represents the underlying value.
                //
                if (field.Calculated)
                    valueAsString = valueAsString.Substring(valueAsString.IndexOf(";#", StringComparison.Ordinal) + 2);

                //
                // Parse the value based on the type set on the field mapping attribute.
                //
                switch (field.FieldType)
                {
                    //
                    // Booleans are represented as 0, 1 or some string representation compatible with System.Boolean.Parse.
                    //
                    case FieldType.Boolean:
                        bool bb = (valueAsString == "1" ? true : (valueAsString == "0" ? false : bool.Parse(valueAsString)));
                        if (entity == null)
                            property.SetValue(target, bb, null);
                        else
                            entity.SetValue(property.Name, bb);
                        break;
                    //
                    // DateTime values can be parsed using System.DateTime.Parse.
                    //
                    case FieldType.DateTime:
                        DateTime dt = DateTime.ParseExact(valueAsString, "yyyy-MM-dd HH:mm:ss", new CultureInfo("en-us")); //FIX hh to HH (check!)
                        if (entity == null)
                            property.SetValue(target, dt, null);
                        else
                            entity.SetValue(property.Name, dt);
                        break;
                    //
                    // Counter field represents an integer and is used in primary key values. (v0.2.0.0)
                    //
                    case FieldType.Counter:
                        int pk = int.Parse(valueAsString, new CultureInfo("en-us"));
                        if (entity == null)
                            property.SetValue(target, pk, null);
                        else
                            entity.SetValue(property.Name, pk);
                        break;
                    //
                    // Number and Currency values are represented as floats that can be parsed using System.Double.Parse.
                    //
                    case FieldType.Number:
                    case FieldType.Currency:
                        double dd = double.Parse(valueAsString, new CultureInfo("en-us"));
                        if (entity == null)
                            property.SetValue(target, dd, null);
                        else
                            entity.SetValue(property.Name, dd);
                        break;
                    //
                    // Integer values are 32-bit signed numbers that can be parsed using System.Int32.Parse.
                    //
                    case FieldType.Integer:
                        int ii = int.Parse(valueAsString, new CultureInfo("en-us"));
                        if (entity == null)
                            property.SetValue(target, ii, null);
                        else
                            entity.SetValue(property.Name, ii);
                        break;
                    //
                    // For URL values, a custom Url class has been defined that knows how to parse a SharePoint URL value to a Uri and a friendly name.
                    //
                    case FieldType.URL:
                        Url url = new Url(valueAsString);
                        if (entity == null)
                            property.SetValue(target, url, null);
                        else
                            entity.SetValue(property.Name, url);
                        break;
                    //
                    // Text and Note values are plain simple strings.
                    //
                    case FieldType.Text:
                    case FieldType.Note:
                        if (entity == null)
                            property.SetValue(target, valueAsString, null);
                        else
                            entity.SetValue(property.Name, valueAsString);
                        break;
                    //
                    // Lookup fields represent n-to-1 mappings and require lazy loading of the referenced list entity.
                    //
                    case FieldType.Lookup:
                        //
                        // Structure will be key;#display where key represents the foreign key and display the display field.
                        //
                        string[] fk = valueAsString.Split(new string[] { ";#" }, StringSplitOptions.None);
                        if (fk.Length != 2)
                            break;
                        int fkey = int.Parse(fk[0], CultureInfo.InvariantCulture.NumberFormat);

                        //
                        // We'll only support lazy loading on entity types that implement SharePointListEntity.
                        //
                        if (entity == null)
                            throw new NotSupportedException("Lookup fields are only supported on entity types deriving from SharePointListEntity. Did you use SpMetal to generate the entity class?");
                        else
                        {
                            //
                            // Lazy loading
                            //
                            Type t = typeof(LazyLoadingThunk<>).MakeGenericType(property.PropertyType);
                            ILazyLoadingThunk thunk = (ILazyLoadingThunk)Activator.CreateInstance(t, _context, fkey);
                            entity.SetValue(property.Name, thunk);
                        }
                        break;
                    //
                    // LookupMulti fields represent n-to-m mappings and require lazy loading of the referenced list entities.
                    //
                    case FieldType.LookupMulti:
                        //
                        // Structure will be [key;#display]* where key represents the foreign key and display the display field.
                        //
                        string[] fks = valueAsString.Split(new string[] { ";#" }, StringSplitOptions.None);
                        if (fks.Length % 2 != 0)
                            break;
                        List<int> lstFkeys = new List<int>();
                        for (int i = 0; i < fks.Length; i += 2)
                            lstFkeys.Add(int.Parse(fks[i], CultureInfo.InvariantCulture.NumberFormat));
                        int[] fkeys = lstFkeys.ToArray();

                        //
                        // We'll only support lazy loading on entity types that implement SharePointListEntity.
                        //
                        if (entity == null)
                            throw new NotSupportedException("Lookup fields are only supported on entity types deriving from SharePointListEntity. Did you use SpMetal to generate the entity class?");
                        else
                        {
                            //
                            // Lazy loading.
                            //
                            Type t = typeof(LazyLoadingThunk<>).MakeGenericType(property.PropertyType.GetGenericArguments()[0]);
                            ILazyLoadingThunk thunk = (ILazyLoadingThunk)Activator.CreateInstance(t, _context, fkeys);
                            entity.SetValue(property.Name, thunk);
                        }
                        break;
                    default:
                        throw new InvalidOperationException("Unrecognized mapping type encountered: " + field.FieldType + ".");
                }
            }
            //
            // If the type is not an enum or a string, we can assume it has the right type for direct assignment to the property.
            //
            else
            {
                if (entity == null)
                    property.SetValue(target, val, null);
                else
                    entity.SetValue(property.Name, val);
            }
        }

        /// <summary>
        /// Helper method to assign an enum property on a result object.
        /// </summary>
        /// <param name="property">Property to assign a value to.</param>
        /// <param name="target">Target object to assign a property value to.</param>
        /// <param name="field">Field attribute of the entity type field to assign to. Used to determine the "other choice" field.</param>
        /// <param name="val">Value to be assigned as an enum with possible "other choice".</param>
        /// <param name="propertyType">Type of the underlying enumeration.</param>
        /// <returns>Value of the enum corresponding to the val parameter.</returns>
        private static object AssignResultPropertyAsEnum(PropertyInfo property, object target, FieldAttribute field, object val, Type propertyType)
        {
            //
            // Convert to entity to set property values via SetValue method if an entity type is used.
            //
            SharePointListEntity entity = target as SharePointListEntity;

            //
            // Find all of the choices of the enum type. A reverse mapping from SharePoint CHOICE names to enum field names is maintained, which will be used to allow Enum.Parse calls further on.
            //
            HashSet<string> choices = new HashSet<string>();
            Dictionary<string, string> reverseMapping = new Dictionary<string, string>();
            foreach (string f in Enum.GetNames(propertyType))
            {
                //
                // Custom mapping of enum field to CHOICE value?
                //
                ChoiceAttribute[] ca = propertyType.GetField(f).GetCustomAttributes(typeof(ChoiceAttribute), false) as ChoiceAttribute[];
                if (ca != null && ca.Length != 0 && ca[0] != null)
                {
                    choices.Add(ca[0].Choice);

                    //
                    // Maintain the reverse mapping from the SharePoint CHOICE name to the enum field name.
                    //
                    reverseMapping.Add(ca[0].Choice, f);
                }
                else
                    choices.Add(f);
            }

            //
            // The value can be converted to a string in case of (Multi)Choice results. Each choice value is separated by ;#, so we'll split the set of choices.
            // From this set of individual choices, we can filter out the known values, which will leave us with a possible fill-in choice.
            //
            string[] vs = ((string)val).Replace(";#", ",").Trim(',', ' ').Split(',');
            HashSet<string> knownVals = new HashSet<string>(vs);
            knownVals.IntersectWith(choices);

            //
            // In order to get the value that needs to be assigned to the property we'll take all of the known values and map them back to enum field names.
            // The resulting comma-separated string with known choices can be parsed using Enum.Parse to get the final result.
            //
            StringBuilder sb = new StringBuilder();
            foreach (string s in knownVals)
                sb.AppendFormat("{0}, ", reverseMapping.ContainsKey(s) ? reverseMapping[s] : s);

            string v = sb.ToString().TrimEnd(',', ' ');
            if (v.Length != 0)
            {
                val = Enum.Parse(propertyType, v);

                if (entity == null)
                    property.SetValue(target, val, null);
                else
                    entity.SetValue(property.Name, val);

                //property.SetValue(target, val, null); //FIX v0.1.3
            }

            //
            // Now a set of remaining values is constructed by taking the original set of values and removing all known values.
            //
            HashSet<string> otherVals = new HashSet<string>(vs);
            foreach (string s in knownVals)
                otherVals.Remove(s);

            //
            // We expect zero or one other value. In the latter case, this will serve as the input for the "other field".
            //
            string other = null;
            if (otherVals.Count == 1)
                other = otherVals.ToArray()[0];
            else if (otherVals.Count > 1)
                throw new InvalidOperationException("More than one unknown choice value encountered for field " + property.Name + ". Only one fill-in value is supported. Is the entity mapping for the list outdated?");

            //
            // If an other value is found, process it as a fill-in choice for the MultiChoice field.
            //
            if (other != null)
            {
                //
                // Find the field used for the fill-in choice.
                //
                string otherField = field.OtherChoice;
                if (otherField != null)
                {
                    PropertyInfo pOther = property.DeclaringType.GetProperty(otherField);
                    //
                    // Assign the fill-in choice value to the OtherChoice field.
                    //
                    if (pOther != null)
                        pOther.SetValue(target, other, null);
                    else
                        throw new InvalidOperationException("Invalid OtherChoice field mapping for MultiChoice field " + property.Name + ".");
                }
                else
                    throw new InvalidOperationException("An unknown fill-in choice value was encountered for field " + property.Name + " but an OtherChoice field mapping is missing. Is the entity mapping for the list outdated?");
            }
            return val;
        }

        #endregion

        #endregion
    }

    [Serializable]
    public class ParseError
    {
        public string Message { get; private set; }
        public int StartIndex { get; private set; }
        public int EndIndex { get; private set; }
        public int ErrorId { get; private set; }

        public ParseError(int id, string message, int startIndex, int endIndex)
        {
            ErrorId = id;
            Message = message;
            StartIndex = startIndex;
            EndIndex = endIndex;
        }
    }

    [Serializable]
    public class ParseErrorCollection : List<ParseError>
    {
        public string Expression { get; set; }
    }

    internal static class ParseErrors
    {
        public static XmlElement UnsupportedQueryOperator(CamlQuery query, string queryOperator, int start, int end)
        {
            return KeepOrThrow(String.Format("Query operator {0} is not supported.", queryOperator), query, start, end);
        }

        public static XmlElement CantNegate(CamlQuery query, string expression, int start, int end)
        {
            return KeepOrThrow(String.Format("Can't negate a {0} query expression.", expression), query, start, end);
        }

        private static XmlElement KeepOrThrow(string message, CamlQuery query, int start, int end)
        {
            if (query._errors != null)
            {
                int id = query._errors.Count + 1;
                query._errors.Add(new ParseError(id, message, start, end));

                XmlElement error = query._doc.CreateElement("ParseError");
                XmlAttribute idAttribute = query._doc.CreateAttribute("ID");
                idAttribute.Value = id.ToString();
                error.Attributes.Append(idAttribute);
                return error;
            }
            else
                throw new NotSupportedException(message);
        }
    }
}