/*
 * LINQ to SharePoint
 * http://www.codeplex.com/LINQtoSharePoint
 * 
 * Copyright Bart De Smet (C) 2007
 * info@bartdesmet.net - http://blogs.bartdesmet.net/bart
 * 
 * This project is subject to licensing restrictions. Visit http://www.codeplex.com/LINQtoSharePoint/Project/License.aspx for more information.
 */

/*
 * Version history:
 * 
 * 0.2.0 - Restructuring of class files in project
 *         Hosting model with events
 * 0.2.1 - Use of CodeDom for code generation; move from SpMetal code to EntityGenerator
 * 0.2.2 - New entity model
 * 0.2.3 - New SPML run modes
 */

#region Namespace imports

using System;
using System.Linq;
using System.CodeDom;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Text;
using System.Xml;
using Microsoft.SharePoint;
using System.Web.Services.Protocols;
using System.IO;
using System.Xml.Schema;
using System.Reflection;
using System.Globalization;

#endregion

namespace BdsSoft.SharePoint.Linq.Tools.EntityGenerator
{
    /// <summary>
    /// Generates code for entity classes based on the list schema exported from SharePoint.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    public class Generator
    {
        #region Events

        /// <summary>
        /// Connecting to the SharePoint site.
        /// </summary>
        public event EventHandler<ConnectingEventArgs> Connecting;

        /// <summary>
        /// Connected to the SharePoint site.
        /// </summary>
        public event EventHandler<ConnectedEventArgs> Connected;

        /// <summary>
        /// Loading schema from the SharePoint site.
        /// </summary>
        public event EventHandler<LoadingSchemaEventArgs> LoadingSchema;

        /// <summary>
        /// Schema loaded from the SharePoint site.
        /// </summary>
        public event EventHandler<LoadedSchemaEventArgs> LoadedSchema;

        /// <summary>
        /// Exporting schema from the SharePoint site.
        /// </summary>
        public event EventHandler<ExportingSchemaEventArgs> ExportingSchema;

        /// <summary>
        /// Schema exported from the SharePoint site.
        /// </summary>
        public event EventHandler<ExportedSchemaEventArgs> ExportedSchema;

        #endregion

        #region Private members

        /// <summary>
        /// List of type definitions that have been generated by the entity generator.
        /// </summary>
        private List<CodeTypeDeclaration> _types = new List<CodeTypeDeclaration>();

        /// <summary>
        /// Dictionary of entity type definitions mapped by list name.
        /// </summary>
        private Dictionary<Guid, CodeTypeDeclaration> _entities = new Dictionary<Guid, CodeTypeDeclaration>();

        /// <summary>
        /// Context used in back-mapping of SPML during code-generation.
        /// </summary>
        private Context _context;

        /// <summary>
        /// Set of assigned type names that shouldn't be used in type name generation (<seealso cref="GetTypeName"/>).
        /// </summary>
        private HashSet<string> _typeNames = new HashSet<string>();

        /// <summary>
        /// Invocation arguments for the entity generator.
        /// </summary>
        private EntityGeneratorArgs _args;

        #endregion

        #region Public members

        /// <summary>
        /// Creates a new entity generator.
        /// </summary>
        /// <param name="args">Invocation arguments.</param>
        public Generator(EntityGeneratorArgs args)
        {
            _args = args;
        }

        /// <summary>
        /// Generates a SPML document based on the given arguments.
        /// </summary>
        /// <param name="contextName">Prefix for the custom SharePointDataContext type's name.</param>
        /// <param name="listNames">Names of the lists to generate entity types for.</param>
        /// <returns>SPML document with exported entity information.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Spml")]
        public XmlDocument GenerateSpml(string contextName, params string[] listNames)
        {
            //
            // Create Context object and set parameters.
            //
            Context context = new Context();
            context.Name = contextName;
            context.Url = _args.Connection.Url;
            context.Connection = _args.Connection;

            if (listNames == null || listNames.Length == 0)
            {
                // Get all lists here.
            }
            else
            {
                //
                // Calculate closure of lists, including Lookup(Multi) referenced lists.
                //
                Dictionary<Guid, List> closure = new Dictionary<Guid, List>();
                foreach (string lst in listNames)
                {
                    List list = List.FromCaml(GetListDefinition(lst));
                    if (!closure.ContainsKey(list.Id))
                    {
                        closure.Add(list.Id, list);

                        //
                        // Search for referenced lists in the known fields collection.
                        //
                        foreach (Field field in list.GetKnownFields())
                        {
                            if (field.FieldType == FieldType.Lookup || field.FieldType == FieldType.LookupMulti)
                            {
                                List lookupList = List.FromCaml(GetListDefinition(field.LookupList));
                                if (!closure.ContainsKey(lookupList.Id))
                                    closure.Add(lookupList.Id, lookupList);
                            }
                        }
                    }
                }

                //
                // Set the Lists property of the context.
                //
                context.Lists = new List<List>(closure.Values);
            }

            XmlDocument doc = new XmlDocument();
            doc.AppendChild(doc.ImportNode(context.ToSpml(), true));
            return doc;
        }

        /// <summary>
        /// Generates entity types based on the given arguments.
        /// </summary>
        /// <param name="spml">SPML definition to generate code for.</param>
        /// <returns>Code compilation unit for all required entity types and helper types.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1059:MembersShouldNotExposeCertainConcreteTypes", MessageId = "System.Xml.XmlNode"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "spml")]
        public CodeCompileUnit GenerateCode(XmlDocument spml)
        {
            if (spml == null)
                throw new ArgumentNullException("spml");

            //
            // Validate the SPML input.
            //
            List<ValidationEventArgs> messages;
            if (!ValidateSpml(spml, out messages))
            {
                EntityGeneratorException ex = new EntityGeneratorException("SPML validation failed.");
                ex.Data.Add("messages", messages);
                throw ex;
            }

            //
            // Get the SharePointDataContext root.
            //
            _context = Context.FromSpml(spml["SharePointDataContext"]);

            //
            // Create code unit in specified namespace.
            //
            CodeCompileUnit compileUnit = new CodeCompileUnit();
            CodeNamespace ns = new CodeNamespace(_args.Namespace);
            compileUnit.Namespaces.Add(ns);

            //
            // Add required namespace imports.
            //
            ns.Imports.Add(new CodeNamespaceImport("System"));
            ns.Imports.Add(new CodeNamespaceImport("System.Collections.Generic"));
            ns.Imports.Add(new CodeNamespaceImport("BdsSoft.SharePoint.Linq"));

            //
            // Prepare entities.
            //
            Dictionary<List, string> mapping = new Dictionary<List, string>();
            foreach (List list in _context.Lists)
            {
                string name = GetTypeName(!string.IsNullOrEmpty(list.EntityAlias) ? list.EntityAlias : list.Name);
                _entities.Add(list.Id, new CodeTypeDeclaration(name));
                mapping.Add(list, name);
            }

            //
            // Generate entities.
            //
            foreach (List list in _context.Lists)
                GenerateEntityForList(list);

            //
            // Add generated types to namespace.
            //
            foreach (CodeTypeDeclaration type in _types)
                ns.Types.Add(type);

            //
            // Create a custom SharePointDataContext type.
            //
            if (!string.IsNullOrEmpty(_context.Name))
            {
                CodeTypeDeclaration ctx = GenerateSharePointDataContext(_context, mapping);
                ns.Types.Add(ctx);
            }

            //
            // Return compile unit.
            //
            return compileUnit;
        }

        /// <summary>
        /// Validates the SPML document against the SPML schema.
        /// </summary>
        /// <param name="spml">SPML document to validate.</param>
        /// <param name="messages">Validation messages.</param>
        /// <returns>true if validation succeeded; otherwise, false.</returns>
        private static bool ValidateSpml(XmlDocument spml, out List<ValidationEventArgs> messages)
        {
            if (spml == null)
                throw new ArgumentNullException("spml");

            //
            // Get the resource with the SPML XSD definition.
            //
            Assembly a = Assembly.GetExecutingAssembly();
            string xsd = a.GetName().Name + ".SPML.xsd";
            spml.Schemas = new XmlSchemaSet();
            using (Stream s = a.GetManifestResourceStream(xsd))
                spml.Schemas.Add(XmlSchema.Read(s, null));

            //
            // Validate.
            //
            bool success = true;
            List<ValidationEventArgs> msgs = new List<ValidationEventArgs>();
            spml.Validate(
                delegate (object sender, ValidationEventArgs e)
                {
                    msgs.Add(e);
                    if (e.Severity == XmlSeverityType.Error)
                        success = false;
                }
            );
            messages = msgs;
            return success;
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Generates the type definition for a custom SharePointDataContext object, holding property references to the list objects.
        /// </summary>
        /// <param name="context">Context definition to create the SharePointDataContext for.</param>
        /// <param name="entityNames">Entities to be included in the custom data context.</param>
        /// <returns>Type definition of a custom SharePointDataContext with property references to the specified lists.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        private static CodeTypeDeclaration GenerateSharePointDataContext(Context context, Dictionary<List, string> entities)
        {
            //
            // Create CodeDOM context type.
            //
            CodeTypeDeclaration ctx = new CodeTypeDeclaration(Helpers.GetFriendlyName(context.Name) + "SharePointDataContext");
            ctx.Attributes = MemberAttributes.Public;
            ctx.IsPartial = true;
            ctx.BaseTypes.Add(new CodeTypeReference(typeof(SharePointDataContext), CodeTypeReferenceOptions.GlobalReference));
            ctx.IsClass = true;

            //
            // Add constructors.
            //
            CodeConstructor wsCtor = new CodeConstructor();
            wsCtor.Attributes = MemberAttributes.Public;
            wsCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            wsCtor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Uri), "wsUri"));
            wsCtor.BaseConstructorArgs.Add(new CodeSnippetExpression("wsUri"));
            wsCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            wsCtor.Comments.Add(new CodeCommentStatement("Connect to SharePoint using the SharePoint web services.", true));
            wsCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            wsCtor.Comments.Add(new CodeCommentStatement("<param name=\"wsUri\">URI to the SharePoint site.</param>", true));
            ctx.Members.Add(wsCtor);

            CodeConstructor omCtor = new CodeConstructor();
            omCtor.Attributes = MemberAttributes.Public;
            omCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            omCtor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(SPSite), "site"));
            omCtor.BaseConstructorArgs.Add(new CodeSnippetExpression("site"));
            omCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            omCtor.Comments.Add(new CodeCommentStatement("Connect to SharePoint using the SharePoint object model.", true));
            omCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            omCtor.Comments.Add(new CodeCommentStatement("<param name=\"site\">SharePoint site object.</param>", true));
            ctx.Members.Add(omCtor);

            CodeConstructor customCtor = new CodeConstructor();
            customCtor.Attributes = MemberAttributes.Public;
            customCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            customCtor.BaseConstructorArgs.Add(new CodeObjectCreateExpression(new CodeTypeReference(typeof(Uri), CodeTypeReferenceOptions.GlobalReference), new CodePrimitiveExpression(context.Url.ToString())));
            customCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            customCtor.Comments.Add(new CodeCommentStatement("Connect to the " + context.Url.ToString() + " SharePoint site using the SharePoint web services.", true));
            customCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            ctx.Members.Add(customCtor);

            //
            // Add entity properties.
            //
            foreach (List entity in entities.Keys)
            {
                //
                // Create and add property for the list.
                //
                CodeMemberProperty ep = new CodeMemberProperty();
                ep.Attributes = MemberAttributes.Public | MemberAttributes.Final;
                ep.Name = Helpers.GetFriendlyName(!string.IsNullOrEmpty(entity.ListAlias) ? entity.ListAlias : entity.Name);
                ep.Type = new CodeTypeReference(typeof(SharePointList<>), CodeTypeReferenceOptions.GlobalReference);
                ep.Type.TypeArguments.Add(new CodeTypeReference(entities[entity]));
                ctx.Members.Add(ep);

                //
                // Create getter for the list.
                //
                CodeMethodInvokeExpression getter = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "GetList");
                getter.Method.TypeArguments.Add(new CodeTypeReference(entities[entity]));
                ep.GetStatements.Add(new CodeMethodReturnStatement(getter));

                //
                // Create documentation comment.
                //
                ep.Comments.Add(new CodeCommentStatement("<summary>", true));
                ep.Comments.Add(new CodeCommentStatement(entity.Name + " list.", true));
                ep.Comments.Add(new CodeCommentStatement("</summary>", true));
            }

            //
            // Return custom data context type object.
            //
            return ctx;
        }

        /// <summary>
        /// Generates the type definition for an entity type for the specified list.
        /// </summary>
        /// <param name="list">List to generate the entity type for.</param>
        /// <returns>Entity type definition for the specified list.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
        private CodeTypeDeclaration GenerateEntityForList(List list)
        {
            //
            // Send event about schema exporting.
            //
            EventHandler<ExportingSchemaEventArgs> exportingSchema = ExportingSchema;
            if (exportingSchema != null)
                exportingSchema(this, new ExportingSchemaEventArgs(list.Name, list.Id, list.Version));

            //
            // CodeDOM entity type for list definition.
            //
            CodeTypeDeclaration listType = _entities[list.Id];
            listType.Attributes = MemberAttributes.Public;
            listType.BaseTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanged), CodeTypeReferenceOptions.GlobalReference));
            listType.BaseTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanging), CodeTypeReferenceOptions.GlobalReference));
            listType.IsClass = true;
            listType.IsPartial = true;

            //
            // Custom attribute for list entity type.
            //
            CodeAttributeDeclaration listAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(ListAttribute), CodeTypeReferenceOptions.GlobalReference));
            listAttribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(list.Name)));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(list.Id.ToString())));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Version", new CodePrimitiveExpression(list.Version)));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Path", new CodePrimitiveExpression(list.Path)));
            listType.CustomAttributes.Add(listAttribute);

            //
            // List entity type documentation comments.
            //
            listType.Comments.Add(new CodeCommentStatement("<summary>", true));
            listType.Comments.Add(new CodeCommentStatement(!string.IsNullOrEmpty(list.Description) ? list.Description : list.Name, true));
            listType.Comments.Add(new CodeCommentStatement("</summary>", true));

            //
            // Generate field definitions.
            //
            int n = GenerateFieldDefinitions(list, listType);

            //
            // Event model: events.
            //
            listType.Members.Add(GetEventModelEvent("PropertyChanging"));
            listType.Members.Add(GetEventModelEvent("PropertyChanged"));

            //
            // Event model: On* methods.
            //
            listType.Members.Add(GetEventModelMethod("PropertyChanging"));
            listType.Members.Add(GetEventModelMethod("PropertyChanged"));

            //
            // Send event about schema exporting completion.
            //
            EventHandler<ExportedSchemaEventArgs> exportedSchema = ExportedSchema;
            if (exportedSchema != null)
                exportedSchema(this, new ExportedSchemaEventArgs(n));

            //
            // Keep entity type definition.
            //
            _types.Add(listType);

            //
            // Return type definition.
            //
            return listType;
        }

        /// <summary>
        /// Generates the field definition for the specified list and writes them to the specified list type CodeDOM element.
        /// </summary>
        /// <param name="list">List to export field definitions for.</param>
        /// <param name="listType">CodeDOM output element.</param>
        /// <returns>Number of exported fields.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes")]
        private int GenerateFieldDefinitions(List list, CodeTypeDeclaration listType)
        {
            int n = 0;
            foreach (Field field in list.GetKnownFields())
            {
                //
                // Build FieldAttribute attribute.
                //
                List<CodeAttributeArgument> fieldAttributeArgs = new List<CodeAttributeArgument>();
                fieldAttributeArgs.Add(new CodeAttributeArgument(new CodePrimitiveExpression(XmlConvert.DecodeName(field.Name))));
                fieldAttributeArgs.Add(
                    new CodeAttributeArgument(
                        new CodeFieldReferenceExpression(
                            new CodeTypeReferenceExpression(new CodeTypeReference(typeof(FieldType), CodeTypeReferenceOptions.GlobalReference)),
                            Enum.GetName(typeof(FieldType), field.FieldType)
                        )
                    )
                );
                fieldAttributeArgs.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(field.Id.ToString())));

                //
                // Read-only and calculated field require additional mapping attribute parameters.
                //
                if (field.IsPrimaryKey)
                    fieldAttributeArgs.Add(new CodeAttributeArgument("PrimaryKey", new CodePrimitiveExpression(true)));
                if (field.IsReadOnly)
                    fieldAttributeArgs.Add(new CodeAttributeArgument("ReadOnly", new CodePrimitiveExpression(true)));
                if (field.IsCalculated)
                    fieldAttributeArgs.Add(new CodeAttributeArgument("Calculated", new CodePrimitiveExpression(true)));

                //
                // Create helper field and refer to it in case a multi-choice fields with fill-in choice was detected.
                // The helper field has the same name as the .NET type (which will be an enum) suffixed with "Other".
                //
                if (field.FillInChoiceEnabled)
                    fieldAttributeArgs.Add(new CodeAttributeArgument("OtherChoice", new CodePrimitiveExpression(Helpers.GetHelperName(field.DisplayName))));

                //
                // Runtime type for entity property. Will be supplied in type-specific switching logic below.
                // Keep track of value (and Nullable) types for VB code generation (compare using .Equals instead of Is or =).
                // Keep track of Lookup and LookupMulti fields for special code generation.
                //
                CodeTypeReference bclTypeRef;
                bool isValue = false;
                bool isLookup = false;
                bool isLookupMulti = false;

                //
                // Type-specific generation actions; generate other entities or choice enums if required.
                //
                switch (field.FieldType)
                {
                    case FieldType.Choice:
                    case FieldType.MultiChoice:
                        isValue = true;
                        bool flags = field.FieldType == FieldType.MultiChoice;
                        if (field.IsRequired)
                            bclTypeRef = new CodeTypeReference(GenerateChoiceEnum(field, flags));
                        else
                        {
                            bclTypeRef = new CodeTypeReference(typeof(Nullable<>), CodeTypeReferenceOptions.GlobalReference);
                            bclTypeRef.TypeArguments.Add(new CodeTypeReference(GenerateChoiceEnum(field, flags)));
                        }
                        break;
                    case FieldType.Lookup:
                    case FieldType.LookupMulti:
                        {
                            Guid? lookup = null;
                            try
                            {
                                lookup = new Guid(field.LookupList);
                            }
                            catch { } //No TryParse method found on Guid.

                            CodeTypeDeclaration lookupEntity = null;
                            bool found;
                            if (lookup == null)
                            {
                                List lookupList = (from l in _context.Lists where l.Name == field.LookupList select l).SingleOrDefault();
                                found = lookupList != null && _entities.ContainsKey(lookupList.Id);
                                if (found)
                                    lookupEntity = _entities[lookupList.Id];
                            }
                            else
                            {
                                found = _entities.ContainsKey(lookup.Value);
                                if (found)
                                    lookupEntity = _entities[lookup.Value];
                            }

                            if (lookupEntity != null)
                                bclTypeRef = new CodeTypeReference(lookupEntity.Name);
                            else
                                throw new EntityGeneratorException(String.Format(CultureInfo.InvariantCulture, "Invalid Lookup field list reference encountered: list {0} referred to by field {1} is unknown in the SharePoint context.", field.LookupList, field.Name));
                            fieldAttributeArgs.Add(new CodeAttributeArgument("LookupDisplayField", new CodePrimitiveExpression(field.LookupField)));

                            //
                            // Lookup fields are mapped on EntityRef<T> properties.
                            //
                            if (field.FieldType == FieldType.Lookup)
                            {
                                isLookup = true;
                            }
                            //
                            // LookupMulti fields are mapped on EntitySet<T> properties.
                            //
                            else
                            {
                                isLookupMulti = true;

                                CodeTypeReference t = bclTypeRef;
                                bclTypeRef = new CodeTypeReference(typeof(EntitySet<>), CodeTypeReferenceOptions.GlobalReference);
                                bclTypeRef.TypeArguments.Add(t);
                            }
                        }
                        break;
                    default:
                        bclTypeRef = new CodeTypeReference(field.RuntimeType, CodeTypeReferenceOptions.GlobalReference);
                        if (field.RuntimeType.IsGenericType)
                            isValue = (field.RuntimeType.GetGenericTypeDefinition() == typeof(Nullable<>));
                        else
                            isValue = (field.RuntimeType.BaseType == typeof(System.ValueType));
                        break;
                }

                //
                // LookupMulti fields shouldn't be settable. The underlying EntitySet<T> type will allow changes to the collection though.
                //
                bool readOnly = field.FieldType != FieldType.LookupMulti ? field.IsReadOnly : true;

                //
                // Create field property definition.
                //
                string fieldName = Helpers.GetFriendlyName(!string.IsNullOrEmpty(field.Alias) ? field.Alias : field.DisplayName);
                CodeMemberField storageField;
                CodeMemberProperty fieldProperty = GetFieldMemberProperty(listType, field.DisplayName, field.Description, readOnly, bclTypeRef, isValue, fieldName, fieldAttributeArgs, false, isLookup, isLookupMulti, out storageField);
                listType.Members.Add(fieldProperty);
                listType.Members.Add(storageField);

                //
                // Generate additional helper property if needed.
                //
                if (field.FillInChoiceEnabled && (field.FieldType == FieldType.Choice || field.FieldType == FieldType.MultiChoice))
                {
                    //
                    // Fill-in choice field is of type Text. Create FieldAttribute accordingly.
                    //
                    List<CodeAttributeArgument> helperFieldAttributeArgs = new List<CodeAttributeArgument>();
                    helperFieldAttributeArgs.Add(new CodeAttributeArgument(new CodePrimitiveExpression(XmlConvert.DecodeName(field.Name))));
                    helperFieldAttributeArgs.Add(
                        new CodeAttributeArgument(
                            new CodeFieldReferenceExpression(
                                new CodeTypeReferenceExpression(typeof(FieldType)),
                                Enum.GetName(typeof(FieldType), field.FieldType)
                            )
                        )
                    );

                    //
                    // Use same field Id as the helper's parent.
                    //
                    helperFieldAttributeArgs.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(field.Id.ToString())));

                    //
                    // Create field definition for helper.
                    //
                    CodeMemberField helperStorageField;
                    CodeMemberProperty helperField = GetFieldMemberProperty(listType, field.DisplayName, field.DisplayName + " 'Fill-in' value", false, new CodeTypeReference(typeof(string), CodeTypeReferenceOptions.GlobalReference), false, fieldName, helperFieldAttributeArgs, true, false, false, out helperStorageField);
                    listType.Members.Add(helperField);
                    listType.Members.Add(helperStorageField);
                }

                //
                // Keep field count.
                //
                n++;
            }
            return n;
        }

        /// <summary>
        /// Gets the entity event model's event definition for the specified event.
        /// </summary>
        /// <param name="eventName">Event to generate event definition for.</param>
        /// <returns>Event definition.</returns>
        private CodeMemberEvent GetEventModelEvent(string eventName)
        {
            CodeMemberEvent evt = new CodeMemberEvent();
            evt.Attributes = MemberAttributes.Public;
            evt.Name = eventName;

            if (eventName == "PropertyChanging")
            {
                evt.Type = new CodeTypeReference(typeof(System.ComponentModel.PropertyChangingEventHandler), CodeTypeReferenceOptions.GlobalReference);
                if (_args.Language == Language.VB)
                    evt.ImplementationTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanging), CodeTypeReferenceOptions.GlobalReference));
            }
            else
            {
                evt.Type = new CodeTypeReference(typeof(System.ComponentModel.PropertyChangedEventHandler), CodeTypeReferenceOptions.GlobalReference);
                if (_args.Language == Language.VB)
                    evt.ImplementationTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanged), CodeTypeReferenceOptions.GlobalReference));
            }

            return evt;
        }

        /// <summary>
        /// Gets the entity event model's event invocation method for the specified event.
        /// </summary>
        /// <param name="eventName">Event to generate event invocation method for.</param>
        /// <returns>Event invocation method definition.</returns>
        private CodeMemberMethod GetEventModelMethod(string eventName)
        {
            //
            // Declaration.
            //
            CodeMemberMethod method = new CodeMemberMethod();
            method.Attributes = MemberAttributes.Family | MemberAttributes.Final;
            method.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.Diagnostics.DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            method.Name = "On" + eventName;
            CodeParameterDeclarationExpression param = new CodeParameterDeclarationExpression(typeof(string), "propertyName");
            method.Parameters.Add(param);

            //
            // Statements.
            //
            CodeExpression left = new CodeEventReferenceExpression(new CodeThisReferenceExpression(), eventName);
            CodeExpression right = new CodePrimitiveExpression(null);

            CodeExpression cond;
            if (_args.Language == Language.CSharp)
                cond =
                    new CodeBinaryOperatorExpression(
                        left,
                        CodeBinaryOperatorType.IdentityInequality,
                        right
                    );
            else
                cond =
                    new CodeBinaryOperatorExpression(
                        new CodeBinaryOperatorExpression(
                            left,
                            CodeBinaryOperatorType.IdentityEquality,
                            right
                        ),
                        CodeBinaryOperatorType.ValueEquality,
                        new CodePrimitiveExpression(false)
                    );
            CodeExpression eventArgs;
            if (eventName == "PropertyChanging")
                eventArgs = new CodeObjectCreateExpression(new CodeTypeReference(typeof(System.ComponentModel.PropertyChangingEventArgs), CodeTypeReferenceOptions.GlobalReference), new CodeSnippetExpression(param.Name));
            else
                eventArgs = new CodeObjectCreateExpression(new CodeTypeReference(typeof(System.ComponentModel.PropertyChangedEventArgs), CodeTypeReferenceOptions.GlobalReference), new CodeSnippetExpression(param.Name));
            CodeStatement trues = new CodeExpressionStatement(new CodeDelegateInvokeExpression(left, new CodeThisReferenceExpression(), eventArgs));
            CodeConditionStatement condition = new CodeConditionStatement(cond, trues);
            method.Statements.Add(condition);

            //
            // Return result.
            //
            return method;
        }

        /// <summary>
        /// Generate an enum type for the specified Choice or MultiChoice field.
        /// </summary>
        /// <param name="field">Field to generate enum type for.</param>
        /// <param name="flags">Should be set to true for MultiChoice fields, indicating the enum values can be combined (flags).</param>
        /// <returns>Enum type definition for the specified field.</returns>
        private string GenerateChoiceEnum(Field field, bool flags)
        {
            //
            // Generate name for enum.
            //
            string name = GetTypeName(XmlConvert.DecodeName(field.Name));

            //
            // Multi-choice values are mapped onto flag enums. A variable is kept for the flag value which should be a power of two.
            //
            int flagValue = 1;

            //
            // Create enum definition.
            //
            CodeTypeDeclaration enumType = new CodeTypeDeclaration(name);
            enumType.BaseTypes.Add(typeof(uint));
            enumType.Attributes = MemberAttributes.Public;
            enumType.IsEnum = true;
            if (flags)
                enumType.CustomAttributes.Add(new CodeAttributeDeclaration("Flags"));

            //
            // Populate the enum with the choices available in the list field definition.
            //
            HashSet<string> choices = new HashSet<string>();
            foreach (Choice c in field.Choices)
            {
                //
                // Get friendly name for choice value.
                //
                string choice = Helpers.GetFriendlyName(!string.IsNullOrEmpty(c.Alias) ? c.Alias : c.Name);

                //
                // Detect duplicate values; shouldn't occur in most cases.
                //
                string s = choice;
                int j = 2;
                while (choices.Contains(s))
                    s = choice + (j++);
                choices.Add(s);

                //
                // Create field definition and set flag value in case a flags enum is generated.
                //
                CodeMemberField choiceField = new CodeMemberField(typeof(uint), choice);
                if (flags)
                    choiceField.InitExpression = new CodePrimitiveExpression(flagValue);

                //
                // Add code documentation.
                //
                choiceField.Comments.Add(new CodeCommentStatement("<summary>", true));
                choiceField.Comments.Add(new CodeCommentStatement(!string.IsNullOrEmpty(c.Description) ? c.Description : c.Name, true));
                choiceField.Comments.Add(new CodeCommentStatement("</summary>", true));

                //
                // Add an enum field mapping in case the field name doesn't match the underlying SharePoint choice value textual represention.
                //
                if (choice != c.Name)
                {
                    choiceField.CustomAttributes.Add(
                        new CodeAttributeDeclaration(
                            new CodeTypeReference(typeof(ChoiceAttribute), CodeTypeReferenceOptions.GlobalReference),
                            new CodeAttributeArgument(new CodePrimitiveExpression(c.Name))
                        )
                    );
                }

                //
                // Add the created field to the enum.
                //
                enumType.Members.Add(choiceField);

                //
                // Update the flags value by multiplying it by two.
                //
                flagValue *= 2;
            }

            //
            // Keep enum definition.
            //
            _types.Add(enumType);

            //
            // Return enum type name.
            //
            return name;
        }

        /// <summary>
        /// Generates the property definition for the specified SharePoint list field.
        /// </summary>
        /// <param name="listType">List type the field and property are generated for.</param>
        /// <param name="displayName">Display name of the list field.</param>
        /// <param name="description">Description of the list field.</param>
        /// <param name="readOnly">Indicates whether or not the list field is read-only.</param>
        /// <param name="bclTypeRef">Type reference for the runtime type to be used for the generated property.</param>
        /// <param name="isValue">Indicates whether the target type is a value type or not.</param>
        /// <param name="fieldName">Name to be used for the generated property.</param>
        /// <param name="fieldAttributeArgs">Custom attribute arguments for the FieldAttribute on the generated property.</param>
        /// <param name="isHelper">Indicates whether or not the field is used as a helper field.</param>
        /// <param name="isLookup">Indicates whether or not the field is a Lookup field.</param>
        /// <param name="isLookupMulti">Indicates whether or not the field is a LookupMulti field.</param>
        /// <param name="field">Storage field for the property.</param>
        /// <returns>Property definition for the specified SharePoint list field.</returns>
        private CodeMemberProperty GetFieldMemberProperty(CodeTypeDeclaration listType, string displayName, string description, bool readOnly, CodeTypeReference bclTypeRef, bool isValue, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, bool isHelper, bool isLookup, bool isLookupMulti, out CodeMemberField field)
        {
            //
            // Property definition for the field.
            //
            CodeMemberProperty prop = new CodeMemberProperty();
            prop.Name = Uniquify(listType, isHelper ? Helpers.GetHelperName(fieldName) : fieldName);
            prop.Type = bclTypeRef;
            prop.Attributes = MemberAttributes.Public | MemberAttributes.Final;

            //
            // Add documentation comments.
            //
            prop.Comments.Add(new CodeCommentStatement("<summary>", true));
            prop.Comments.Add(new CodeCommentStatement(description ?? displayName, true));
            prop.Comments.Add(new CodeCommentStatement("</summary>", true));

            if (isLookup)
            {
                //
                // Field definition.
                //
                CodeTypeReference type = new CodeTypeReference(typeof(EntityRef<>), CodeTypeReferenceOptions.GlobalReference);
                type.TypeArguments.Add(bclTypeRef);
                field = new CodeMemberField(type, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetLookupMemberProperty(prop, prop.Name, fieldAttributeArgs, field);
            }
            else if (isLookupMulti)
            {
                //
                // Field definition.
                //
                field = new CodeMemberField(bclTypeRef, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetLookupMultiMemberProperty(prop, fieldAttributeArgs, field);
            }
            else
            {
                //
                // Field definition.
                //
                field = new CodeMemberField(bclTypeRef, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetMemberProperty(prop, readOnly, isValue, prop.Name, fieldAttributeArgs, field);
            }

            //
            // Read-only fields should have the default value assigned to avoid compile-time warnings.
            //
            if (readOnly && _args.Language == Language.CSharp)
                field.InitExpression = new CodeDefaultValueExpression(field.Type);

            //
            // Return the property definition.
            //
            return prop;
        }

        private Dictionary<CodeTypeDeclaration, HashSet<string>> propertyNames = new Dictionary<CodeTypeDeclaration, HashSet<string>>();

        private string Uniquify(CodeTypeDeclaration listType, string name)
        {
            if (!propertyNames.ContainsKey(listType))
                propertyNames.Add(listType, new HashSet<string>());

            HashSet<string> properties = propertyNames[listType];

            string s = name;
            int j = 2;
            while (properties.Contains(s))
                s = name + (j++);
            properties.Add(s);

            return s;
        }

        private void SetMemberProperty(CodeMemberProperty prop, bool readOnly, bool isValue, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef =
                new CodeFieldReferenceExpression(
                    new CodeThisReferenceExpression(),
                    field.Name
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            if (readOnly)
                prop.HasSet = false;
            else
            {
                CodeExpression cond;
                if (_args.Language == Language.CSharp)
                {
                    cond = new CodeBinaryOperatorExpression(
                        fieldRef,
                        CodeBinaryOperatorType.IdentityInequality,
                        new CodePropertySetValueReferenceExpression()
                    );
                }
                else
                {
                    if (!isValue)
                        cond = new CodeBinaryOperatorExpression(
                            new CodeBinaryOperatorExpression(
                                fieldRef,
                                CodeBinaryOperatorType.IdentityEquality,
                                new CodePropertySetValueReferenceExpression()
                            ),
                            CodeBinaryOperatorType.ValueEquality,
                            new CodePrimitiveExpression(false)
                        );
                    else
                        cond = new CodeBinaryOperatorExpression(
                            new CodeMethodInvokeExpression(
                                fieldRef,
                                "Equals",
                                new CodePropertySetValueReferenceExpression()
                            ),
                            CodeBinaryOperatorType.ValueEquality,
                            new CodePrimitiveExpression(false)
                        );
                }

                prop.SetStatements.Add(
                    new CodeConditionStatement(
                        cond,
                        new CodeExpressionStatement(
                            new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanging", new CodePrimitiveExpression(fieldName))
                        ),
                        new CodeAssignStatement(fieldRef, new CodePropertySetValueReferenceExpression()),
                        new CodeExpressionStatement(
                            new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanged", new CodePrimitiveExpression(fieldName))
                        )
                    )
                );
            }

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        private void SetLookupMemberProperty(CodeMemberProperty prop, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef =
                new CodePropertyReferenceExpression(
                    new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(),
                        field.Name
                    ),
                    "Entity"
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            CodeExpression cond;
            if (_args.Language == Language.CSharp)
            {
                cond = new CodeBinaryOperatorExpression(
                    fieldRef,
                    CodeBinaryOperatorType.IdentityInequality,
                    new CodePropertySetValueReferenceExpression()
                );
            }
            else
            {
                cond = new CodeBinaryOperatorExpression(
                    new CodeBinaryOperatorExpression(
                        fieldRef,
                        CodeBinaryOperatorType.IdentityEquality,
                        new CodePropertySetValueReferenceExpression()
                    ),
                    CodeBinaryOperatorType.ValueEquality,
                    new CodePrimitiveExpression(false)
                );
            }

            prop.SetStatements.Add(
                new CodeConditionStatement(
                    cond,
                    new CodeExpressionStatement(
                        new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanging", new CodePrimitiveExpression(fieldName))
                    ),
                    new CodeAssignStatement(fieldRef, new CodePropertySetValueReferenceExpression()),
                    new CodeExpressionStatement(
                        new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanged", new CodePrimitiveExpression(fieldName))
                    )
                )
            );

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        private static void SetLookupMultiMemberProperty(CodeMemberProperty prop, List<CodeAttributeArgument> fieldAttributeArgs, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef =
                new CodeFieldReferenceExpression(
                    new CodeThisReferenceExpression(),
                    field.Name
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            prop.SetStatements.Add(
                new CodeMethodInvokeExpression(
                    fieldRef,
                    "Assign",
                    new CodePropertySetValueReferenceExpression()
                )
            );

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        /// <summary>
        /// Gets the XML definition of the specified list by querying the SharePoint Lists web service.
        /// </summary>
        /// <param name="list">List to get the XML definition for.</param>
        /// <returns>XML definition for the specified list.</returns>
        private XmlNode GetListDefinition(string list)
        {
            //
            // List definition XML; will be downloaded from server.
            //
            XmlNode lst;

            //
            // Create proxy object referring to the SharePoint lists.asmx service on the specified server.
            //
            Lists l = new Lists();
            l.Url = _args.Connection.Url.ToString().TrimEnd('/') + "/_vti_bin/lists.asmx";

            //
            // Try to connect to server.
            //
            try
            {
                //
                // Send event about connection.
                //
                EventHandler<ConnectingEventArgs> connecting = Connecting;
                if (connecting != null)
                    connecting(this, new ConnectingEventArgs(new Uri(l.Url)));

                //
                // Integrated authentication using current network credentials.
                //
                if (!_args.Connection.CustomAuthentication)
                    l.Credentials = CredentialCache.DefaultNetworkCredentials;
                //
                // Use specified credentials.
                //
                else
                {
                    if (_args.Connection.Domain == null)
                        l.Credentials = new NetworkCredential(_args.Connection.User, _args.Connection.Password);
                    else
                        l.Credentials = new NetworkCredential(_args.Connection.User, _args.Connection.Password, _args.Connection.Domain);
                }

                //
                // Send event about connection completion.
                //
                EventHandler<ConnectedEventArgs> connected = Connected;
                if (connected != null)
                    connected(this, new ConnectedEventArgs());
            }
            catch (Exception ex)
            {
                //
                // Send event about connection failure.
                //
                EventHandler<ConnectedEventArgs> connected = Connected;
                if (connected != null)
                    connected(this, new ConnectedEventArgs(ex));

                throw new EntityGeneratorException("Failed to connect to the SharePoint site at " + _args.Connection.Url + ".", ex);
            }

            try
            {
                //
                // Load schema from server using lists.asmx web service and send event about schema loading.
                //
                EventHandler<LoadingSchemaEventArgs> loadingSchema = LoadingSchema;
                if (loadingSchema != null)
                    loadingSchema(this, new LoadingSchemaEventArgs(list));
                lst = l.GetList(list);

                //
                // Send event about schema loading completion.
                //
                EventHandler<LoadedSchemaEventArgs> loadedSchema = LoadedSchema;
                if (loadedSchema != null)
                    loadedSchema(this, new LoadedSchemaEventArgs());
            }
            catch (WebException ex)
            {
                //
                // Send event about schema loading failure.
                //
                EventHandler<LoadedSchemaEventArgs> loadedSchema = LoadedSchema;
                if (loadedSchema != null)
                    loadedSchema(this, new LoadedSchemaEventArgs(ex));

                throw new EntityGeneratorException("Failed to connect to the SharePoint site at " + _args.Connection.Url + ".", ex);
            }
            catch (SoapException ex)
            {
                //
                // Send event about schema loading failure.
                //
                EventHandler<LoadedSchemaEventArgs> loadedSchema = LoadedSchema;
                if (loadedSchema != null)
                    loadedSchema(this, new LoadedSchemaEventArgs(ex));

                throw new EntityGeneratorException("Cannot load the list definition for " + list + ".", ex);
            }

            return lst;
        }

        /// <summary>
        /// Gets a unique name for a type based on the specified name.
        /// </summary>
        /// <param name="name">Name to create a unique type name for.</param>
        /// <returns>Unique type name.</returns>
        private string GetTypeName(string name)
        {
            name = Helpers.GetFriendlyName(name.Trim());

            int j = 0;
            string s = name;
            while (_typeNames.Contains(s))
                s = name + j++;
            _typeNames.Add(s);
            return s;
        }

        #endregion
    }

    [Serializable]
    public class EntityGeneratorException : Exception
    {
        public EntityGeneratorException() { }
        public EntityGeneratorException(string message) : base(message) { }
        public EntityGeneratorException(string message, Exception inner) : base(message, inner) { }
        protected EntityGeneratorException(
          System.Runtime.Serialization.SerializationInfo info,
          System.Runtime.Serialization.StreamingContext context)
            : base(info, context) { }
    }

    public class XsdError
    {

    }
}
