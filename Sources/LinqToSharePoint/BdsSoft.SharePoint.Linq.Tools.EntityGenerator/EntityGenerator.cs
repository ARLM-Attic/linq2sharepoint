/*
 * LINQ to SharePoint
 * http://www.codeplex.com/LINQtoSharePoint
 * 
 * Copyright Bart De Smet (C) 2007
 * info@bartdesmet.net - http://blogs.bartdesmet.net/bart
 * 
 * This project is subject to licensing restrictions. Visit http://www.codeplex.com/LINQtoSharePoint/Project/License.aspx for more information.
 */

/*
 * Version history:
 * 
 * 0.2.0 - Restructuring of class files in project
 *         Hosting model with events
 * 0.2.1 - Use of CodeDom for code generation; move from SpMetal code to EntityGenerator
 * 0.2.2 - New entity model
 */

#region Namespace imports

using System;
using System.CodeDom;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Text;
using System.Xml;
using Microsoft.SharePoint;

#endregion

namespace BdsSoft.SharePoint.Linq.Tools.EntityGenerator
{
    /// <summary>
    /// Generates code for entity classes based on the list schema exported from SharePoint.
    /// </summary>
    public class EntityGenerator
    {
        #region Events

        /// <summary>
        /// Connecting to the SharePoint site.
        /// </summary>
        public event EventHandler<ConnectingEventArgs> Connecting;

        /// <summary>
        /// Connected to the SharePoint site.
        /// </summary>
        public event EventHandler<ConnectedEventArgs> Connected;

        /// <summary>
        /// Loading schema from the SharePoint site.
        /// </summary>
        public event EventHandler<LoadingSchemaEventArgs> LoadingSchema;

        /// <summary>
        /// Schema loaded from the SharePoint site.
        /// </summary>
        public event EventHandler<LoadedSchemaEventArgs> LoadedSchema;

        /// <summary>
        /// Exporting schema from the SharePoint site.
        /// </summary>
        public event EventHandler<ExportingSchemaEventArgs> ExportingSchema;

        /// <summary>
        /// Schema exported from the SharePoint site.
        /// </summary>
        public event EventHandler<ExportedSchemaEventArgs> ExportedSchema;

        #endregion

        #region Private members

        /// <summary>
        /// List of type definitions that have been generated by the entity generator.
        /// </summary>
        private List<CodeTypeDeclaration> types = new List<CodeTypeDeclaration>();

        /// <summary>
        /// Dictionary of entity type definitions mapped by list name.
        /// </summary>
        private Dictionary<string, CodeTypeDeclaration> entities = new Dictionary<string, CodeTypeDeclaration>();

        /// <summary>
        /// Set of assigned type names that shouldn't be used in type name generation (<seealso cref="GetTypeName"/>).
        /// </summary>
        private HashSet<string> typeNames = new HashSet<string>();

        /// <summary>
        /// Invocation arguments for the entity generator.
        /// </summary>
        private EntityGeneratorArgs args;

        #endregion

        #region Public members

        /// <summary>
        /// Creates a new entity generator.
        /// </summary>
        /// <param name="args">Invocation arguments.</param>
        public EntityGenerator(EntityGeneratorArgs args)
        {
            this.args = args;
        }

        /// <summary>
        /// Generates entity types based on the given arguments.
        /// </summary>
        /// <param name="contextName">Prefix for the custom SharePointDataContext type's name. No custom context will be created if this parameter is null or the empty string.</param>
        /// <param name="listNames">Names of the lists to generate entity types for.</param>
        /// <returns>Code compilation unit for all required entity types and helper types.</returns>
        public CodeCompileUnit Generate(string contextName, params string[] listNames)
        {
            //
            // Create code unit in specified namespace.
            //
            CodeCompileUnit compileUnit = new CodeCompileUnit();
            CodeNamespace ns = new CodeNamespace(args.Namespace);
            compileUnit.Namespaces.Add(ns);

            //
            // Add required namespace imports.
            //
            ns.Imports.Add(new CodeNamespaceImport("System"));
            ns.Imports.Add(new CodeNamespaceImport("System.Collections.Generic"));
            ns.Imports.Add(new CodeNamespaceImport("BdsSoft.SharePoint.Linq"));

            //
            // Generate entities.
            //
            foreach (string list in listNames)
                GenerateEntityForList(list);

            //
            // Add generated types to namespace.
            //
            foreach (CodeTypeDeclaration type in types)
                ns.Types.Add(type);

            //
            // Create a custom SharePointDataContext type.
            //
            if (!string.IsNullOrEmpty(contextName))
            {
                List<string> entities = new List<CodeTypeDeclaration>(this.entities.Values).ConvertAll<string>(t => t.Name);
                CodeTypeDeclaration ctx = GenerateSharePointDataContext(contextName, entities.ToArray());
                ns.Types.Add(ctx);
            }

            //
            // Return compile unit.
            //
            return compileUnit;
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Generates the type definition for a custom SharePointDataContext object, holding property references to the list objects.
        /// </summary>
        /// <param name="contextName">Friendly name to create the SharePointDataContext for, e.g. the WSS site name.</param>
        /// <param name="entityNames">List of entity type names to be included in the custom data context.</param>
        /// <returns>Type definition of a custom SharePointDataContext with property references to the specified lists.</returns>
        private CodeTypeDeclaration GenerateSharePointDataContext(string contextName, params string[] entityNames)
        {
            //
            // Create CodeDOM context type.
            //
            CodeTypeDeclaration ctx = new CodeTypeDeclaration(contextName + "SharePointDataContext");
            ctx.Attributes = MemberAttributes.Public;
            ctx.IsPartial = true;
            ctx.BaseTypes.Add(new CodeTypeReference(typeof(SharePointDataContext), CodeTypeReferenceOptions.GlobalReference));
            ctx.IsClass = true;

            //
            // Add constructors.
            //
            CodeConstructor wsCtor = new CodeConstructor();
            wsCtor.Attributes = MemberAttributes.Public;
            wsCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            wsCtor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(Uri), "wsUri"));
            wsCtor.BaseConstructorArgs.Add(new CodeSnippetExpression("wsUri"));
            wsCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            wsCtor.Comments.Add(new CodeCommentStatement("Connect to SharePoint using the SharePoint web services.", true));
            wsCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            wsCtor.Comments.Add(new CodeCommentStatement("<param name=\"wsUri\">URI to the SharePoint site.</param>", true));
            ctx.Members.Add(wsCtor);

            CodeConstructor omCtor = new CodeConstructor();
            omCtor.Attributes = MemberAttributes.Public;
            omCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            omCtor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(SPSite), "site"));
            omCtor.BaseConstructorArgs.Add(new CodeSnippetExpression("site"));
            omCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            omCtor.Comments.Add(new CodeCommentStatement("Connect to SharePoint using the SharePoint object model.", true));
            omCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            omCtor.Comments.Add(new CodeCommentStatement("<param name=\"site\">SharePoint site object.</param>", true));
            ctx.Members.Add(omCtor);

            CodeConstructor customCtor = new CodeConstructor();
            customCtor.Attributes = MemberAttributes.Public;
            customCtor.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            customCtor.BaseConstructorArgs.Add(new CodeObjectCreateExpression(new CodeTypeReference(typeof(Uri), CodeTypeReferenceOptions.GlobalReference), new CodePrimitiveExpression(args.Url)));
            customCtor.Comments.Add(new CodeCommentStatement("<summary>", true));
            customCtor.Comments.Add(new CodeCommentStatement("Connect to the " + args.Url + " SharePoint site using the SharePoint web services.", true));
            customCtor.Comments.Add(new CodeCommentStatement("</summary>", true));
            ctx.Members.Add(customCtor);

            //
            // Add entity properties.
            //
            foreach (string entity in entityNames)
            {
                //
                // Create and add property for the list.
                //
                CodeMemberProperty ep = new CodeMemberProperty();
                ep.Attributes = MemberAttributes.Public | MemberAttributes.Final;
                ep.Name = entity;
                ep.Type = new CodeTypeReference(typeof(SharePointList<>), CodeTypeReferenceOptions.GlobalReference);
                ep.Type.TypeArguments.Add(new CodeTypeReference(entity));
                ctx.Members.Add(ep);

                //
                // Create getter for the list.
                //
                CodeMethodInvokeExpression getter = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "GetList");
                getter.Method.TypeArguments.Add(new CodeTypeReference(entity));
                ep.GetStatements.Add(new CodeMethodReturnStatement(getter));

                //
                // Create documentation comment.
                //
                ep.Comments.Add(new CodeCommentStatement("<summary>", true));
                ep.Comments.Add(new CodeCommentStatement(entity + " list."));
                ep.Comments.Add(new CodeCommentStatement("</summary>", true));
            }

            //
            // Return custom data context type object.
            //
            return ctx;
        }

        /// <summary>
        /// Generates the type definition for an entity type for the specified list.
        /// </summary>
        /// <param name="listName">List to generate the entity type for.</param>
        /// <returns>Entity type definition for the specified list.</returns>
        private CodeTypeDeclaration GenerateEntityForList(string listName)
        {
            //
            // Get general information of the list.
            //
            XmlNode lst = GetListDefinition(listName);
            List list = List.FromCaml(lst);

            //
            // Check for duplicates.
            //
            if (entities.ContainsKey(list.Id.ToString()))
                return entities[list.Id.ToString()];

            //
            // Send event about schema exporting.
            //
            EventHandler<ExportingSchemaEventArgs> exportingSchema = ExportingSchema;
            if (exportingSchema != null)
                exportingSchema(this, new ExportingSchemaEventArgs(list.Name, list.Id, list.Version));

            //
            // CodeDOM entity type for list definition.
            //
            CodeTypeDeclaration listType = new CodeTypeDeclaration(GetTypeName(list.Name));
            listType.Attributes = MemberAttributes.Public;
            //listType.BaseTypes.Add(new CodeTypeReference(typeof(SharePointListEntity), CodeTypeReferenceOptions.GlobalReference));
            listType.BaseTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanged), CodeTypeReferenceOptions.GlobalReference));
            listType.BaseTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanging), CodeTypeReferenceOptions.GlobalReference));
            listType.IsClass = true;
            listType.IsPartial = true;

            //
            // Keep mapping.
            //
            entities.Add(list.Id.ToString(), listType);

            //
            // Custom attribute for list entity type.
            //
            CodeAttributeDeclaration listAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(ListAttribute), CodeTypeReferenceOptions.GlobalReference));
            listAttribute.Arguments.Add(new CodeAttributeArgument(new CodePrimitiveExpression(list.Name)));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(list.Id.ToString())));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Version", new CodePrimitiveExpression(list.Version)));
            listAttribute.Arguments.Add(new CodeAttributeArgument("Path", new CodePrimitiveExpression(list.Path)));
            listType.CustomAttributes.Add(listAttribute);

            //
            // List entity type documentation comments.
            //
            listType.Comments.Add(new CodeCommentStatement("<summary>", true));
            listType.Comments.Add(new CodeCommentStatement(list.Description ?? list.Name, true));
            listType.Comments.Add(new CodeCommentStatement("</summary>", true));

            //
            // Generate field definitions.
            //
            int n = 0;
            foreach (Field field in list.Fields)
            {
                //
                // Export only fields that aren't hidden or the primary key field.
                //
                if (!field.IsHidden || field.IsPrimaryKey)
                {
                    //
                    // Is the underlying type recognized and supported by the mapper?
                    //
                    if (field.FieldType != FieldType.None)
                    {
                        //
                        // Build FieldAttribute attribute.
                        //
                        List<CodeAttributeArgument> fieldAttributeArgs = new List<CodeAttributeArgument>();
                        fieldAttributeArgs.Add(new CodeAttributeArgument(new CodePrimitiveExpression(XmlConvert.DecodeName(field.Name))));
                        fieldAttributeArgs.Add(
                            new CodeAttributeArgument(
                                new CodeFieldReferenceExpression(
                                    new CodeTypeReferenceExpression(new CodeTypeReference(typeof(FieldType), CodeTypeReferenceOptions.GlobalReference)),
                                    Enum.GetName(typeof(FieldType), field.FieldType)
                                )
                            )
                        );
                        fieldAttributeArgs.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(field.Id.ToString())));

                        //
                        // Read-only and calculated field require additional mapping attribute parameters.
                        //
                        if (field.IsPrimaryKey)
                            fieldAttributeArgs.Add(new CodeAttributeArgument("PrimaryKey", new CodePrimitiveExpression(true)));
                        if (field.IsReadOnly)
                            fieldAttributeArgs.Add(new CodeAttributeArgument("ReadOnly", new CodePrimitiveExpression(true)));
                        if (field.IsCalculated)
                            fieldAttributeArgs.Add(new CodeAttributeArgument("Calculated", new CodePrimitiveExpression(true)));

                        //
                        // Create helper field and refer to it in case a multi-choice fields with fill-in choice was detected.
                        // The helper field has the same name as the .NET type (which will be an enum) suffixed with "Other".
                        //
                        if (field.FillInChoiceEnabled)
                            fieldAttributeArgs.Add(new CodeAttributeArgument("OtherChoice", new CodePrimitiveExpression(Helpers.GetHelperName(field.DisplayName))));

                        //
                        // Runtime type for entity property. Will be supplied in type-specific switching logic below.
                        // Keep track of value (and Nullable) types for VB code generation (compare using .Equals instead of Is or =).
                        // Keep track of Lookup and LookupMulti fields for special code generation.
                        //
                        CodeTypeReference bclTypeRef;
                        bool isValue = false;
                        bool isLookup = false;
                        bool isLookupMulti = false;

                        //
                        // Type-specific generation actions; generate other entities or choice enums if required.
                        //
                        switch (field.FieldType)
                        {
                            case FieldType.Choice:
                            case FieldType.MultiChoice:
                                isValue = true;
                                bool flags = field.FieldType == FieldType.MultiChoice;
                                if (field.IsRequired)
                                    bclTypeRef = new CodeTypeReference(GenerateChoiceEnum(field, flags));
                                else
                                {
                                    bclTypeRef = new CodeTypeReference(typeof(Nullable<>), CodeTypeReferenceOptions.GlobalReference);
                                    bclTypeRef.TypeArguments.Add(new CodeTypeReference(GenerateChoiceEnum(field, flags)));
                                }
                                break;
                            case FieldType.Lookup:
                            case FieldType.LookupMulti:
                                {
                                    if (entities.ContainsKey(field.LookupList))
                                        bclTypeRef = new CodeTypeReference(entities[field.LookupList].Name);
                                    else
                                        bclTypeRef = new CodeTypeReference(GenerateEntityForList(field.LookupList).Name);
                                    fieldAttributeArgs.Add(new CodeAttributeArgument("LookupDisplayField", new CodePrimitiveExpression(field.LookupField)));

                                    //
                                    // Lookup fields are mapped on EntityRef<T> properties.
                                    //
                                    if (field.FieldType == FieldType.Lookup)
                                    {
                                        isLookup = true;
                                    }
                                    //
                                    // LookupMulti fields are mapped on EntitySet<T> properties.
                                    //
                                    else
                                    {
                                        isLookupMulti = true;

                                        CodeTypeReference t = bclTypeRef;
                                        //bclTypeRef = new CodeTypeReference(typeof(IList<>), CodeTypeReferenceOptions.GlobalReference);
                                        bclTypeRef = new CodeTypeReference(typeof(EntitySet<>), CodeTypeReferenceOptions.GlobalReference);
                                        bclTypeRef.TypeArguments.Add(t);
                                    }
                                }
                                break;
                            default:
                                bclTypeRef = new CodeTypeReference(field.RuntimeType, CodeTypeReferenceOptions.GlobalReference);
                                if (field.RuntimeType.IsGenericType)
                                    isValue = (field.RuntimeType.GetGenericTypeDefinition() == typeof(Nullable<>));
                                else
                                    isValue = (field.RuntimeType.BaseType == typeof(System.ValueType));
                                break;
                        }

                        //
                        // LookupMulti fields shouldn't be settable. The underlying IList<T> type will allow changes to the collection though.
                        //
                        bool readOnly = field.FieldType != FieldType.LookupMulti ? field.IsReadOnly : true;

                        //
                        // Create field property definition.
                        //
                        string fieldName = Helpers.GetFriendlyName(field.DisplayName);
                        CodeMemberField storageField;
                        CodeMemberProperty fieldProperty = GetFieldMemberProperty(listType, field.DisplayName, field.Description, readOnly, bclTypeRef, isValue, fieldName, fieldAttributeArgs, false, isLookup, isLookupMulti, out storageField);
                        listType.Members.Add(fieldProperty);
                        listType.Members.Add(storageField);

                        //
                        // Generate additional helper property if needed.
                        //
                        if (field.FillInChoiceEnabled && (field.FieldType == FieldType.Choice || field.FieldType == FieldType.MultiChoice))
                        {
                            //
                            // Fill-in choice field is of type Text. Create FieldAttribute accordingly.
                            //
                            List<CodeAttributeArgument> helperFieldAttributeArgs = new List<CodeAttributeArgument>();
                            helperFieldAttributeArgs.Add(new CodeAttributeArgument(new CodePrimitiveExpression(XmlConvert.DecodeName(field.Name))));
                            helperFieldAttributeArgs.Add(
                                new CodeAttributeArgument(
                                    new CodeFieldReferenceExpression(
                                        new CodeTypeReferenceExpression(typeof(FieldType)),
                                        Enum.GetName(typeof(FieldType), field.FieldType)
                                    )
                                )
                            );

                            //
                            // Use same field Id as the helper's parent.
                            //
                            helperFieldAttributeArgs.Add(new CodeAttributeArgument("Id", new CodePrimitiveExpression(field.Id.ToString())));

                            //
                            // Create field definition for helper.
                            //
                            CodeMemberField helperStorageField;
                            CodeMemberProperty helperField = GetFieldMemberProperty(listType, field.DisplayName, field.DisplayName + " 'Fill-in' value", false, new CodeTypeReference(typeof(string), CodeTypeReferenceOptions.GlobalReference), false, fieldName, helperFieldAttributeArgs, true, false, false, out helperStorageField);
                            listType.Members.Add(helperField);
                            listType.Members.Add(helperStorageField);
                        }

                        //
                        // Keep field count.
                        //
                        n++;
                    }
                }
            }

            //
            // Event model: events.
            //
            listType.Members.Add(GetEventModelEvent("PropertyChanging"));
            listType.Members.Add(GetEventModelEvent("PropertyChanged"));

            //
            // Event model: On* methods.
            //
            listType.Members.Add(GetEventModelMethod("PropertyChanging"));
            listType.Members.Add(GetEventModelMethod("PropertyChanged"));

            //
            // Send event about schema exporting completion.
            //
            EventHandler<ExportedSchemaEventArgs> exportedSchema = ExportedSchema;
            if (exportedSchema != null)
                exportedSchema(this, new ExportedSchemaEventArgs(n));

            //
            // Keep entity type definition.
            //
            types.Add(listType);

            //
            // Return type definition.
            //
            return listType;
        }

        /// <summary>
        /// Gets the entity event model's event definition for the specified event.
        /// </summary>
        /// <param name="eventName">Event to generate event definition for.</param>
        /// <returns>Event definition.</returns>
        private CodeMemberEvent GetEventModelEvent(string eventName)
        {
            CodeMemberEvent evt = new CodeMemberEvent();
            evt.Attributes = MemberAttributes.Public;
            evt.Name = eventName;

            if (eventName == "PropertyChanging")
            {
                evt.Type = new CodeTypeReference(typeof(System.ComponentModel.PropertyChangingEventHandler), CodeTypeReferenceOptions.GlobalReference);
                if (args.Language == Language.VB)
                    evt.ImplementationTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanging), CodeTypeReferenceOptions.GlobalReference));
            }
            else
            {
                evt.Type = new CodeTypeReference(typeof(System.ComponentModel.PropertyChangedEventHandler), CodeTypeReferenceOptions.GlobalReference);
                if (args.Language == Language.VB)
                    evt.ImplementationTypes.Add(new CodeTypeReference(typeof(System.ComponentModel.INotifyPropertyChanged), CodeTypeReferenceOptions.GlobalReference));
            }

            return evt;
        }

        private CodeMemberMethod GetEventModelMethod(string eventName)
        {
            //
            // Declaration.
            //
            CodeMemberMethod method = new CodeMemberMethod();
            method.Attributes = MemberAttributes.Family | MemberAttributes.Final;
            method.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(System.Diagnostics.DebuggerNonUserCodeAttribute), CodeTypeReferenceOptions.GlobalReference)));
            method.Name = "On" + eventName;
            CodeParameterDeclarationExpression param = new CodeParameterDeclarationExpression(typeof(string), "propertyName");
            method.Parameters.Add(param);

            //
            // Statements.
            //
            CodeExpression left = new CodeEventReferenceExpression(new CodeThisReferenceExpression(), eventName);
            CodeExpression right = new CodePrimitiveExpression(null);

            CodeExpression cond;
            if (args.Language == Language.CSharp)
                cond =
                    new CodeBinaryOperatorExpression(
                        left,
                        CodeBinaryOperatorType.IdentityInequality,
                        right
                    );
            else
                cond =
                    new CodeBinaryOperatorExpression(
                        new CodeBinaryOperatorExpression(
                            left,
                            CodeBinaryOperatorType.IdentityEquality,
                            right
                        ),
                        CodeBinaryOperatorType.ValueEquality,
                        new CodePrimitiveExpression(false)
                    );
            CodeExpression eventArgs;
            if (eventName == "PropertyChanging")
                eventArgs = new CodeObjectCreateExpression(new CodeTypeReference(typeof(System.ComponentModel.PropertyChangingEventArgs), CodeTypeReferenceOptions.GlobalReference), new CodeSnippetExpression(param.Name));
            else
                eventArgs = new CodeObjectCreateExpression(new CodeTypeReference(typeof(System.ComponentModel.PropertyChangedEventArgs), CodeTypeReferenceOptions.GlobalReference), new CodeSnippetExpression(param.Name));
            CodeStatement trues = new CodeExpressionStatement(new CodeDelegateInvokeExpression(left, new CodeThisReferenceExpression(), eventArgs));
            CodeConditionStatement condition = new CodeConditionStatement(cond, trues);
            method.Statements.Add(condition);

            //
            // Return result.
            //
            return method;
        }

        /// <summary>
        /// Generate an enum type for the specified Choice or MultiChoice field.
        /// </summary>
        /// <param name="field">Field to generate enum type for.</param>
        /// <param name="flags">Should be set to true for MultiChoice fields, indicating the enum values can be combined (flags).</param>
        /// <returns>Enum type definition for the specified field.</returns>
        private string GenerateChoiceEnum(Field field, bool flags)
        {
            //
            // Generate name for enum.
            //
            string name = GetTypeName(field.Name);

            //
            // Multi-choice values are mapped onto flag enums. A variable is kept for the flag value which should be a power of two.
            //
            int flagValue = 1;

            //
            // Create enum definition.
            //
            CodeTypeDeclaration enumType = new CodeTypeDeclaration(name);
            enumType.BaseTypes.Add(typeof(uint));
            enumType.Attributes = MemberAttributes.Public;
            enumType.IsEnum = true;
            if (flags)
                enumType.CustomAttributes.Add(new CodeAttributeDeclaration("Flags"));

            //
            // Populate the enum with the choices available in the list field definition.
            //
            HashSet<string> choices = new HashSet<string>();
            foreach (string c in field.Choices)
            {
                //
                // Get friendly name for choice value.
                //
                string choice = Helpers.GetFriendlyName(c);

                //
                // Detect duplicate values; shouldn't occur in most cases.
                //
                string s = choice;
                int j = 2;
                while (choices.Contains(s))
                    s = choice + (j++);
                choices.Add(s);

                //
                // Create field definition and set flag value in case a flags enum is generated.
                //
                CodeMemberField choiceField = new CodeMemberField(typeof(uint), choice);
                if (flags)
                    choiceField.InitExpression = new CodePrimitiveExpression(flagValue);

                //
                // Add a enum field mapping in case the field name doesn't match the underlying SharePoint choice value textual represention.
                //
                if (choice != c)
                {
                    choiceField.CustomAttributes.Add(
                        new CodeAttributeDeclaration(
                            new CodeTypeReference(typeof(ChoiceAttribute), CodeTypeReferenceOptions.GlobalReference),
                            new CodeAttributeArgument(new CodePrimitiveExpression(c))
                        )
                    );
                }

                //
                // Add the created field to the enum.
                //
                enumType.Members.Add(choiceField);

                //
                // Update the flags value by multiplying it by two.
                //
                flagValue *= 2;
            }

            //
            // Keep enum definition.
            //
            types.Add(enumType);

            //
            // Return enum type name.
            //
            return name;
        }

        /// <summary>
        /// Generates the property definition for the specified SharePoint list field.
        /// </summary>
        /// <param name="listType">List type the field and property are generated for.</param>
        /// <param name="displayName">Display name of the list field.</param>
        /// <param name="description">Description of the list field.</param>
        /// <param name="readOnly">Indicates whether or not the list field is read-only.</param>
        /// <param name="bclTypeRef">Type reference for the runtime type to be used for the generated property.</param>
        /// <param name="isValue">Indicates whether the target type is a value type or not.</param>
        /// <param name="fieldName">Name to be used for the generated property.</param>
        /// <param name="fieldAttributeArgs">Custom attribute arguments for the FieldAttribute on the generated property.</param>
        /// <param name="isHelper">Indicates whether or not the field is used as a helper field.</param>
        /// <param name="isLookup">Indicates whether or not the field is a Lookup field.</param>
        /// <param name="isLookupMulti">Indicates whether or not the field is a LookupMulti field.</param>
        /// <param name="field">Storage field for the property.</param>
        /// <returns>Property definition for the specified SharePoint list field.</returns>
        private CodeMemberProperty GetFieldMemberProperty(CodeTypeDeclaration listType, string displayName, string description, bool readOnly, CodeTypeReference bclTypeRef, bool isValue, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, bool isHelper, bool isLookup, bool isLookupMulti, out CodeMemberField field)
        {
            //
            // Property definition for the field.
            //
            CodeMemberProperty prop = new CodeMemberProperty();
            prop.Name = Uniquify(listType, isHelper ? Helpers.GetHelperName(fieldName) : fieldName);
            prop.Type = bclTypeRef;
            prop.Attributes = MemberAttributes.Public | MemberAttributes.Final;

            //
            // Add documentation comments.
            //
            prop.Comments.Add(new CodeCommentStatement("<summary>", true));
            prop.Comments.Add(new CodeCommentStatement(description ?? displayName, true));
            prop.Comments.Add(new CodeCommentStatement("</summary>", true));

            if (isLookup)
            {
                //
                // Field definition.
                //
                CodeTypeReference type = new CodeTypeReference(typeof(EntityRef<>), CodeTypeReferenceOptions.GlobalReference);
                type.TypeArguments.Add(bclTypeRef);
                field = new CodeMemberField(type, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetLookupMemberProperty(prop, displayName, description, bclTypeRef, prop.Name, fieldAttributeArgs, field);
            }
            else if (isLookupMulti)
            {
                //
                // Field definition.
                //
                field = new CodeMemberField(bclTypeRef, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetLookupMultiMemberProperty(prop, displayName, description, bclTypeRef, prop.Name, fieldAttributeArgs, field);
            }
            else
            {
                //
                // Field definition.
                //
                field = new CodeMemberField(bclTypeRef, "_" + prop.Name);
                fieldAttributeArgs.Add(new CodeAttributeArgument("Storage", new CodePrimitiveExpression(field.Name)));

                SetMemberProperty(prop, displayName, description, readOnly, bclTypeRef, isValue, prop.Name, fieldAttributeArgs, isHelper, field);
            }

            //
            // Read-only fields should have the default value assigned to avoid compile-time warnings.
            //
            if (readOnly && args.Language == Language.CSharp)
                field.InitExpression = new CodeDefaultValueExpression(field.Type);

            //
            // Return the property definition.
            //
            return prop;
        }

        private Dictionary<CodeTypeDeclaration, HashSet<string>> propertyNames = new Dictionary<CodeTypeDeclaration, HashSet<string>>();

        private string Uniquify(CodeTypeDeclaration listType, string name)
        {
            if (!propertyNames.ContainsKey(listType))
                propertyNames.Add(listType, new HashSet<string>());

            HashSet<string> properties = propertyNames[listType];

            string s = name;
            int j = 2;
            while (properties.Contains(s))
                s = name + (j++);
            properties.Add(s);

            return s;
        }

        private void SetMemberProperty(CodeMemberProperty prop, string displayName, string description, bool readOnly, CodeTypeReference bclTypeRef, bool isValue, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, bool isHelper, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef = 
                new CodeFieldReferenceExpression(
                    new CodeThisReferenceExpression(),
                    field.Name
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            if (readOnly)
                prop.HasSet = false;
            else
            {
                CodeExpression cond;
                if (args.Language == Language.CSharp)
                {
                    cond = new CodeBinaryOperatorExpression(
                        fieldRef,
                        CodeBinaryOperatorType.IdentityInequality,
                        new CodePropertySetValueReferenceExpression()
                    );
                }
                else
                {
                    if (!isValue)
                        cond = new CodeBinaryOperatorExpression(
                            new CodeBinaryOperatorExpression(
                                fieldRef,
                                CodeBinaryOperatorType.IdentityEquality,
                                new CodePropertySetValueReferenceExpression()
                            ),
                            CodeBinaryOperatorType.ValueEquality,
                            new CodePrimitiveExpression(false)
                        );
                    else
                        cond = new CodeBinaryOperatorExpression(
                            new CodeMethodInvokeExpression(
                                fieldRef,
                                "Equals",
                                new CodePropertySetValueReferenceExpression()
                            ),
                            CodeBinaryOperatorType.ValueEquality,
                            new CodePrimitiveExpression(false)
                        );
                }

                prop.SetStatements.Add(
                    new CodeConditionStatement(
                        cond,
                        new CodeExpressionStatement(
                            new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanging", new CodePrimitiveExpression(fieldName))
                        ),
                        new CodeAssignStatement(fieldRef, new CodePropertySetValueReferenceExpression()),
                        new CodeExpressionStatement(
                            new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanged", new CodePrimitiveExpression(fieldName))
                        )
                    )
                );
            }

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        private void SetLookupMemberProperty(CodeMemberProperty prop, string displayName, string description, CodeTypeReference bclTypeRef, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef =
                new CodePropertyReferenceExpression(
                    new CodeFieldReferenceExpression(
                        new CodeThisReferenceExpression(),
                        field.Name
                    ),
                    "Entity"
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            CodeExpression cond;
            if (args.Language == Language.CSharp)
            {
                cond = new CodeBinaryOperatorExpression(
                    fieldRef,
                    CodeBinaryOperatorType.IdentityInequality,
                    new CodePropertySetValueReferenceExpression()
                );
            }
            else
            {
                cond = new CodeBinaryOperatorExpression(
                    new CodeBinaryOperatorExpression(
                        fieldRef,
                        CodeBinaryOperatorType.IdentityEquality,
                        new CodePropertySetValueReferenceExpression()
                    ),
                    CodeBinaryOperatorType.ValueEquality,
                    new CodePrimitiveExpression(false)
                );
            }

            prop.SetStatements.Add(
                new CodeConditionStatement(
                    cond,
                    new CodeExpressionStatement(
                        new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanging", new CodePrimitiveExpression(fieldName))
                    ),
                    new CodeAssignStatement(fieldRef, new CodePropertySetValueReferenceExpression()),
                    new CodeExpressionStatement(
                        new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "OnPropertyChanged", new CodePrimitiveExpression(fieldName))
                    )
                )
            );

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        private void SetLookupMultiMemberProperty(CodeMemberProperty prop, string displayName, string description, CodeTypeReference bclTypeRef, string fieldName, List<CodeAttributeArgument> fieldAttributeArgs, CodeMemberField field)
        {
            //
            // Field reference.
            //
            CodeExpression fieldRef =
                new CodeFieldReferenceExpression(
                    new CodeThisReferenceExpression(),
                    field.Name
                );

            //
            // Add getter.
            //
            prop.GetStatements.Add(new CodeMethodReturnStatement(fieldRef));

            //
            // Add setter.
            //
            prop.SetStatements.Add(
                new CodeMethodInvokeExpression(
                    fieldRef,
                    "Assign",
                    new CodePropertySetValueReferenceExpression()
                )
            );

            //
            // Add a FieldAttribute to the property.
            //
            prop.CustomAttributes.Add(
                new CodeAttributeDeclaration(
                    new CodeTypeReference(typeof(FieldAttribute), CodeTypeReferenceOptions.GlobalReference),
                    fieldAttributeArgs.ToArray()
                )
            );
        }

        /// <summary>
        /// Gets the XML definition of the specified list by querying the SharePoint Lists web service.
        /// </summary>
        /// <param name="list">List to get the XML definition for.</param>
        /// <returns>XML definition for the specified list.</returns>
        private XmlNode GetListDefinition(string list)
        {
            //
            // List definition XML; will be downloaded from server.
            //
            XmlNode lst;

            //
            // Create proxy object referring to the SharePoint lists.asmx service on the specified server.
            //
            Lists l = new Lists();
            l.Url = args.Url.TrimEnd('/') + "/_vti_bin/lists.asmx";

            //
            // Try to connect to server.
            //
            try
            {
                //
                // Send event about connection.
                //
                EventHandler<ConnectingEventArgs> connecting = Connecting;
                if (connecting != null)
                    connecting(this, new ConnectingEventArgs(l.Url));

                //
                // Integrated authentication using current network credentials.
                //
                if (args.User == null)
                    l.Credentials = CredentialCache.DefaultNetworkCredentials;
                //
                // Use specified credentials.
                //
                else
                {
                    if (args.Domain == null)
                        l.Credentials = new NetworkCredential(args.User, args.Password);
                    else
                        l.Credentials = new NetworkCredential(args.User, args.Password, args.Domain);
                }

                //
                // Send event about connection completion.
                //
                EventHandler<ConnectedEventArgs> connected = Connected;
                if (connected != null)
                    connected(this, new ConnectedEventArgs());
            }
            catch (Exception ex)
            {
                //
                // Send event about connection failure.
                //
                EventHandler<ConnectedEventArgs> connected = Connected;
                if (connected != null)
                    connected(this, new ConnectedEventArgs(ex));

                return null;
            }

            try
            {
                //
                // Load schema from server using lists.asmx web service and send event about schema loading.
                //
                EventHandler<LoadingSchemaEventArgs> loadingSchema = LoadingSchema;
                if (loadingSchema != null)
                    loadingSchema(this, new LoadingSchemaEventArgs(list));
                lst = l.GetList(list);

                //
                // Send event about schema loading completion.
                //
                EventHandler<LoadedSchemaEventArgs> loadedSchema = LoadedSchema;
                if (loadedSchema != null)
                    loadedSchema(this, new LoadedSchemaEventArgs());
            }
            catch (Exception ex)
            {
                //
                // Send event about schema loading failure.
                //
                EventHandler<LoadedSchemaEventArgs> loadedSchema = LoadedSchema;
                if (loadedSchema != null)
                    loadedSchema(this, new LoadedSchemaEventArgs(ex));

                return null;
            }
            
            return lst;
        }

        /// <summary>
        /// Gets a unique name for a type based on the specified name.
        /// </summary>
        /// <param name="name">Name to create a unique type name for.</param>
        /// <returns>Unique type name.</returns>
        private string GetTypeName(string name)
        {
            name = Helpers.GetFriendlyName(name.Trim());

            int j = 0;
            string s = name;
            while (typeNames.Contains(s))
                s = name + j++;
            typeNames.Add(s);
            return s;
        }

        #endregion
    }
}
